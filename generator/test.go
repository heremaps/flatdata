/////////////////////////////////////////////////////////////////////////
//    ATTENTION!
//    This code is automatically generated by flatdata generator.
//    Any modifications to this file will be lost upon next regeneration.
/////////////////////////////////////////////////////////////////////////
package xyz

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"path/filepath"
	"strconv"

	"github.com/heremaps/flatdata/flatdata-go"
)

const (
    flatdataSizeInBits uint = 64
    indexType32SizeInBytes = 4
    tSizeInBytes = 1
)




// /** Builtin type to for MultiVector index */
type IndexType32 struct {
    internal flatdata.ResourceHandle
	position int64
}

func (v *IndexType32) GetValue() uint64 {
    indexType32SizeInBits  := uint(32)
    indexType32ValueSize         := uint(32)
    indexType32ValueOffset       := uint(0)
    indexType32ValueIsSigned     := false
    b := flatdata.Read(v.internal, flatdataSizeInBits+(indexType32SizeInBits*uint(v.position))+indexType32ValueOffset, indexType32ValueSize, indexType32ValueIsSigned)
    return uint64(b)
}


func (v *IndexType32) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"")
    buffer.WriteString("name")
    buffer.WriteString("\"")
    buffer.WriteString(": ")
    buffer.WriteString("IndexType32")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"")
    buffer.WriteString("position")
    buffer.WriteString("\"")
    buffer.WriteString(": ")
    buffer.WriteString(strconv.Itoa(int(v.position)))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"attributes\": {")
    buffer.WriteString("\n")
    if v.internal != nil {
        buffer.WriteString("    \"")
        buffer.WriteString("value")
        buffer.WriteString("\"")
        buffer.WriteString(": ")
        buffer.WriteString(strconv.Itoa(int(v.GetValue())))
        buffer.WriteString(",")
        buffer.WriteString("\n")
	}
    buffer.WriteString("}")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}


type T struct {
    internal flatdata.ResourceHandle
	position int64
}

func (v *T) GetF0() uint8 {
    tSizeInBits  := uint(3)
    tF0Size         := uint(3)
    tF0Offset       := uint(0)
    tF0IsSigned     := false
    b := flatdata.Read(v.internal, flatdataSizeInBits+(tSizeInBits*uint(v.position))+tF0Offset, tF0Size, tF0IsSigned)
    return uint8(b)
}


func (v *T) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"")
    buffer.WriteString("name")
    buffer.WriteString("\"")
    buffer.WriteString(": ")
    buffer.WriteString("T")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"")
    buffer.WriteString("position")
    buffer.WriteString("\"")
    buffer.WriteString(": ")
    buffer.WriteString(strconv.Itoa(int(v.position)))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"attributes\": {")
    buffer.WriteString("\n")
    if v.internal != nil {
        buffer.WriteString("    \"")
        buffer.WriteString("f0")
        buffer.WriteString("\"")
        buffer.WriteString(": ")
        buffer.WriteString(strconv.Itoa(int(v.GetF0())))
        buffer.WriteString(",")
        buffer.WriteString("\n")
	}
    buffer.WriteString("}")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}

type AVectorResourceVector struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *AVectorResourceVector) Get(i int64) *T {
	return &T{
		internal: v.internal,
		position: i,
	}
}

func (v *AVectorResourceVector) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	intSize := binary.LittleEndian.Uint64(size)
	return int(intSize) / tSizeInBytes
}

func (v *AVectorResourceVector) GetSlice(start, end, step int64) []*T {
	var result []*T	
	for start <= end {
		result = append(result, &T{
			internal: v.internal,
			position: start,
		})
		start += step
	}
	return result
}

func (v *AVectorResourceVector) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *AVectorResourceVector) GetSizeInBytes() int {
    return v.internal.Len()
}

func (v *AVectorResourceVector) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"Vector\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size\": ")
    buffer.WriteString(strconv.Itoa(v.GetSize()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": ")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"element_types\": [")
    buffer.WriteString("\n")
    buffer.WriteString("    {")
    buffer.WriteString("\n")
    buffer.WriteString("        \"name\": \"")
    buffer.WriteString("T")
    buffer.WriteString("\",")
    buffer.WriteString("\n")
    buffer.WriteString("        \"attributes\": [")
    buffer.WriteString("\n")
    buffer.WriteString("            {")
    buffer.WriteString("\n")
    buffer.WriteString("                \"name\": \"")
    buffer.WriteString("f0")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"offset\": ")
    buffer.WriteString(strconv.Itoa(0))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"width\": ")
    buffer.WriteString(strconv.Itoa(3))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"is_signed\": ")
    buffer.WriteString("false")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("            },")
    buffer.WriteString("\n")
    buffer.WriteString("        ]")
    buffer.WriteString("\n")
    buffer.WriteString("    }")
    buffer.WriteString("\n")
    buffer.WriteString("]")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}



type ARawDataResourceRawData struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *ARawDataResourceRawData) GetValue() []byte {
	data := make([]byte, v.GetSize())
	_, err := v.internal.ReadAt(data, 8)
	if err != nil {
		return make([]byte, 0)
	}
	return data
}

func (v *ARawDataResourceRawData) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	return int(binary.LittleEndian.Uint64(size))
}

func (v *ARawDataResourceRawData) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *ARawDataResourceRawData) GetSizeInBytes() int {
    return v.internal.Len()
}

func (v *ARawDataResourceRawData) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"RawData\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size\": ")
    buffer.WriteString(strconv.Itoa(v.GetSize()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": ")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"element_types\": []")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}


type AMultivectorResourceVector struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *AMultivectorResourceVector) Get(i int64) *IndexType32 {
	return &IndexType32{
		internal: v.internal,
		position: i,
	}
}

func (v *AMultivectorResourceVector) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	intSize := binary.LittleEndian.Uint64(size)
	return int(intSize) / indexType32SizeInBytes
}

func (v *AMultivectorResourceVector) GetSlice(start, end, step int64) []*IndexType32 {
	var result []*IndexType32	
	for start <= end {
		result = append(result, &IndexType32{
			internal: v.internal,
			position: start,
		})
		start += step
	}
	return result
}

func (v *AMultivectorResourceVector) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *AMultivectorResourceVector) GetSizeInBytes() int {
    return v.internal.Len()
}

func (v *AMultivectorResourceVector) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"Vector\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size\": ")
    buffer.WriteString(strconv.Itoa(v.GetSize()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": ")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"element_types\": [")
    buffer.WriteString("\n")
    buffer.WriteString("    {")
    buffer.WriteString("\n")
    buffer.WriteString("        \"name\": \"")
    buffer.WriteString("IndexType32")
    buffer.WriteString("\",")
    buffer.WriteString("\n")
    buffer.WriteString("        \"attributes\": [")
    buffer.WriteString("\n")
    buffer.WriteString("            {")
    buffer.WriteString("\n")
    buffer.WriteString("                \"name\": \"")
    buffer.WriteString("value")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"offset\": ")
    buffer.WriteString(strconv.Itoa(0))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"width\": ")
    buffer.WriteString(strconv.Itoa(32))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"is_signed\": ")
    buffer.WriteString("false")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("            },")
    buffer.WriteString("\n")
    buffer.WriteString("        ]")
    buffer.WriteString("\n")
    buffer.WriteString("    }")
    buffer.WriteString("\n")
    buffer.WriteString("]")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}



type AMultivectorResourceMultivector struct {
    internal flatdata.ResourceHandle
    index      *AMultivectorResourceVector
	types      map[int]interface{}
    IsOptional bool
    IsOpen bool
}

func (v *AMultivectorResourceMultivector) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *AMultivectorResourceMultivector) GetSize() int {
	return v.index.GetSize()
}

func (v *AMultivectorResourceMultivector) GetSizeInBytes() int {
    return v.internal.Len()
}

func (v *AMultivectorResourceMultivector) getBucketOffset(i int64) int {
	return int(v.index.Get(i).GetValue()) + int(flatdataSizeInBits / 8)
}

func (v *AMultivectorResourceMultivector) Get(i int) []interface{} {
    offset := v.getBucketOffset(int64(i))
	nextOffset := v.getBucketOffset(int64(i) + 1)
	var result []interface{}

	for offset < nextOffset {
	    elementType := flatdata.Read(v.internal, uint(offset*8), 8, false)
		offset++
		abstractElement, ok := v.types[elementType]
		if !ok {
			//TODO: How to process case, then type of element is not found?
			log.Println("Can't get type of element")
		}
		temp := 0
		switch element := abstractElement.(type) {
		case *T:
			element.position = int64(offset)
			result = append(result, element)
			temp = tSizeInBytes
		default:
			//TODO: How to react in case if it's impossible to cast?
			log.Println("Can't cast element. Type is unknown...")
		}
		offset += temp
	}
	
	return result
}

func (v *AMultivectorResourceMultivector) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"Vector\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size\": ")
    buffer.WriteString(strconv.Itoa(v.GetSize()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": ")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"element_types\": [")
    buffer.WriteString("\n")
    buffer.WriteString("    {")
    buffer.WriteString("\n")
    buffer.WriteString("        \"name\": \"")
    buffer.WriteString("T")
    buffer.WriteString("\",")
    buffer.WriteString("\n")
    buffer.WriteString("        \"attributes\": [")
    buffer.WriteString("\n")
    buffer.WriteString("            {")
    buffer.WriteString("\n")
    buffer.WriteString("                \"name\": \"")
    buffer.WriteString("f0")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"offset\": ")
    buffer.WriteString(strconv.Itoa(0))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"width\": ")
    buffer.WriteString(strconv.Itoa(3))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"is_signed\": ")
    buffer.WriteString("false")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("            },")
    buffer.WriteString("\n")
    buffer.WriteString("        ]")
    buffer.WriteString("\n")
    buffer.WriteString("    },")
    buffer.WriteString("\n")
    buffer.WriteString("],")
    buffer.WriteString("\n")
    buffer.WriteString("    \"index_type\": {")
    buffer.WriteString("\n")
    buffer.WriteString("        \"name\": \"")
    buffer.WriteString("IndexType32")
    buffer.WriteString("\",")
    buffer.WriteString("\n")
    buffer.WriteString("        \"attributes\": [")
    buffer.WriteString("\n")
    buffer.WriteString("            {")
    buffer.WriteString("\n")
    buffer.WriteString("                \"name\": \"")
    buffer.WriteString("value")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"offset\": ")
    buffer.WriteString(strconv.Itoa(0))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"width\": ")
    buffer.WriteString(strconv.Itoa(32))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"is_signed\": ")
    buffer.WriteString("false")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("            }")
    buffer.WriteString("\n")
    buffer.WriteString("        ]")
    buffer.WriteString("\n")
    buffer.WriteString("    }")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}


type AInstanceResourceInstance struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *AInstanceResourceInstance) Get() *T {
	return &T{
	    internal: v.internal,
	}
}

func (v *AInstanceResourceInstance) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	return int(binary.LittleEndian.Uint64(size))
}

func (v *AInstanceResourceInstance) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *AInstanceResourceInstance) GetSizeInBytes() int {
    return v.internal.Len()
}

func (v *AInstanceResourceInstance) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"Vector\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size\": ")
    buffer.WriteString(strconv.Itoa(v.GetSize()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": ")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"element_types\": [")
    buffer.WriteString("\n")
    buffer.WriteString("    {")
    buffer.WriteString("\n")
    buffer.WriteString("        \"name\": \"")
    buffer.WriteString("T")
    buffer.WriteString("\",")
    buffer.WriteString("\n")
    buffer.WriteString("        \"attributes\": [")
    buffer.WriteString("\n")
    buffer.WriteString("            {")
    buffer.WriteString("\n")
    buffer.WriteString("                \"name\": \"")
    buffer.WriteString("f0")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"offset\": ")
    buffer.WriteString(strconv.Itoa(0))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"width\": ")
    buffer.WriteString(strconv.Itoa(3))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"is_signed\": ")
    buffer.WriteString("false")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("            },")
    buffer.WriteString("\n")
    buffer.WriteString("        ]")
    buffer.WriteString("\n")
    buffer.WriteString("    }")
    buffer.WriteString("\n")
    buffer.WriteString("]")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}



type AArchive struct {
    IsOptional bool
    IsOpen bool
    VectorResourceVector *AVectorResourceVector
    RawDataResourceRawData *ARawDataResourceRawData
    MultivectorResourceMultivector *AMultivectorResourceMultivector
    InstanceResourceInstance *AInstanceResourceInstance
}

func (v *AArchive) Close() {
    if v.VectorResourceVector.IsOpen {
        v.VectorResourceVector.Close()
    }
    if v.RawDataResourceRawData.IsOpen {
        v.RawDataResourceRawData.Close()
    }
    if v.MultivectorResourceMultivector.IsOpen {
        v.MultivectorResourceMultivector.Close()
    }
    if v.InstanceResourceInstance.IsOpen {
        v.InstanceResourceInstance.Close()
    }
}

func (v *AArchive) GetSizeInBytes() int {
    var size int
    if v.VectorResourceVector.IsOpen {
        size += v.VectorResourceVector.GetSizeInBytes()
    }
    if v.RawDataResourceRawData.IsOpen {
        size += v.RawDataResourceRawData.GetSizeInBytes()
    }
    if v.MultivectorResourceMultivector.IsOpen {
        size += v.MultivectorResourceMultivector.GetSizeInBytes()
    }
    if v.InstanceResourceInstance.IsOpen {
        size += v.InstanceResourceInstance.GetSizeInBytes()
    }
    return size
}

func (v *AArchive) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"name\": \"")
    buffer.WriteString("A")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"Archive\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": \"")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"resources\": [")
    buffer.WriteString(v.VectorResourceVector.ToString())
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString(v.RawDataResourceRawData.ToString())
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString(v.MultivectorResourceMultivector.ToString())
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString(v.InstanceResourceInstance.ToString())
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("]")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}

func OpenAArchive(resource flatdata.ResourceProvider) (*AArchive, error) {
    v := &AArchive{}
    // Initialize resources
	vectorResourceIsOpen := true
	vectorResourceHandle, schema, err := resource.GetHandle("vector_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        vectorResourceIsOpen = false
	    } else {
		    return v, err
		}
	}
	if vectorResourceIsOpen {
	    vectorResourceSchema := `namespace xyz { struct T {
        f0 : u8 : 3;
    } }
namespace xyz { vector_resource : vector< T >; }`
	    if vectorResourceSchema != schema {
	        log.Println(fmt.Sprintf("Schemas didn't match, expected: \n%s\n, actual: \n%s\n", vectorResourceSchema, schema))
	        return v, errors.New(flatdata.ErrorSchemaDidntMatch)
	    }
	}
	rawDataResourceIsOpen := true
	rawDataResourceHandle, schema, err := resource.GetHandle("raw_data_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        rawDataResourceIsOpen = false
	    } else {
		    return v, err
		}
	}
	if rawDataResourceIsOpen {
	    rawDataResourceSchema := `namespace xyz { raw_data_resource : raw_data; }`
	    if rawDataResourceSchema != schema {
	        log.Println(fmt.Sprintf("Schemas didn't match, expected: \n%s\n, actual: \n%s\n", rawDataResourceSchema, schema))
	        return v, errors.New(flatdata.ErrorSchemaDidntMatch)
	    }
	}
	multivectorResourceIsOpen := true
	multivectorResourceHandle, schema, err := resource.GetHandle("multivector_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        multivectorResourceIsOpen = false
	    } else {
		    return v, err
		}
	}
	multivectorResourceIndexHandle, _, err := resource.GetHandle("multivector_resource_index")
	if err != nil {
	    log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        multivectorResourceIsOpen = false
	    } else {
		    return v, err
		}
	}
	if multivectorResourceIsOpen {
	    multivectorResourceSchema := `namespace xyz { struct T {
        f0 : u8 : 3;
    } }
namespace _builtin.multivector { struct IndexType32 { value : u64 : 32; } }
namespace xyz { multivector_resource : multivector< 32, T >; }`
	    if multivectorResourceSchema != schema {
	        log.Println(fmt.Sprintf("Schemas didn't match, expected: \n%s\n, actual: \n%s\n", multivectorResourceSchema, schema))
	        return v, errors.New(flatdata.ErrorSchemaDidntMatch)
	    }
	}
	instanceResourceIsOpen := true
	instanceResourceHandle, schema, err := resource.GetHandle("instance_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        instanceResourceIsOpen = false
	    } else {
		    return v, err
		}
	}
	if instanceResourceIsOpen {
	    instanceResourceSchema := `namespace xyz { struct T {
        f0 : u8 : 3;
    } }
namespace xyz { instance_resource : T; }`
	    if instanceResourceSchema != schema {
	        log.Println(fmt.Sprintf("Schemas didn't match, expected: \n%s\n, actual: \n%s\n", instanceResourceSchema, schema))
	        return v, errors.New(flatdata.ErrorSchemaDidntMatch)
	    }
	}
	// Add resources to archive
    v.VectorResourceVector = &AVectorResourceVector{
        internal: vectorResourceHandle,
        IsOptional: false,
        IsOpen: vectorResourceIsOpen,
    }
    v.RawDataResourceRawData = &ARawDataResourceRawData{
        internal: rawDataResourceHandle,
        IsOptional: false,
        IsOpen: rawDataResourceIsOpen,
    }
    v.MultivectorResourceMultivector = &AMultivectorResourceMultivector{
        internal: multivectorResourceHandle,
        index: &AMultivectorResourceVector{internal: multivectorResourceIndexHandle},
        types: map[int]interface{}{
            0: &T{internal: multivectorResourceHandle},
        },
        IsOptional: false,
        IsOpen: multivectorResourceIsOpen,
    }
    v.InstanceResourceInstance = &AInstanceResourceInstance {
        internal: instanceResourceHandle,
        IsOptional: false,
        IsOpen: instanceResourceIsOpen,
    }
	return v, nil
}


