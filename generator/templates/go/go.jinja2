/////////////////////////////////////////////////////////////////////////
//    ATTENTION!
//    This code is automatically generated by flatdata generator.
//    Any modifications to this file will be lost upon next regeneration.
/////////////////////////////////////////////////////////////////////////
package {{ tree.root.children[0].name }}

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
{% if tree|contains_archive_resource %}
	"path/filepath"
{% endif %}
	"strconv"

	"github.com/heremaps/flatdata/flatdata-go"
)

const (
    flatdataOffsetSizeInBits uint = 64
    flatdataPaddingSizeInBits uint = 64
{% for node in nodes %}
    {% if node|is_structure %}
    {{ node.name|to_go_case(false) }}SizeInBytes = {{ node.size_in_bytes }}
    {% elif node|is_constant %}
    {{ node.name|to_go_case }} {{ node.type.name|type_mapping(node) }} = {{ node.value }}
    {% endif %}
{% endfor %}
)

{% macro structure_definition(tree, struct) %}
{{ struct|to_go_doc}}
type {{ struct.name|to_go_case }} struct {
    internal flatdata.ResourceHandle
	position int
    multivector bool
}

{% for field in struct.fields %}
func (v *{{ struct.name|to_go_case }}) Get{{ field.name|to_go_case }}() {{ field.type.name|type_mapping_with_bool }} {
    {% if field.doc %}
        {{ field|to_go_doc|indent(8) }}
    {% endif %}
    elementSize := uint({{ field.type.width }})
    elementOffset := uint({{ field.offset }})
    var b int
    if v.multivector {
        b = flatdata.Read(v.internal, (uint(v.position)*8)+elementOffset, elementSize, {{ field.type.is_signed|lower }})
    } else {
        b = flatdata.Read(v.internal, flatdataOffsetSizeInBits+({{ struct.name|to_go_case(false) }}SizeInBytes*8*uint(v.position))+elementOffset, elementSize, {{ field.type.is_signed|lower }})
    }
{% if field.type.name|is_bool %}
    return b == 1
{% else %}
    return {{ field.type.name|type_mapping_with_bool }}(b)
{% endif %}
}

{% endfor %}

func (v *{{ struct.name|to_go_case }}) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"")
    buffer.WriteString("name")
    buffer.WriteString("\"")
    buffer.WriteString(": ")
    buffer.WriteString("{{ struct.name }}")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"")
    buffer.WriteString("position")
    buffer.WriteString("\"")
    buffer.WriteString(": ")
    buffer.WriteString(strconv.Itoa(int(v.position)))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"attributes\": {")
    buffer.WriteString("\n")
    if v.internal != nil {
	    {% for field in struct.fields %}
        buffer.WriteString("    \"")
        buffer.WriteString("{{ field.name }}")
        buffer.WriteString("\"")
        buffer.WriteString(": ")
        {% if field.type.name|is_bool %}
        buffer.WriteString(strconv.FormatBool(v.Get{{ field.name|to_go_case }}()))
        {% else %}
        buffer.WriteString(strconv.Itoa(int(v.Get{{ field.name|to_go_case }}())))
        {% endif %}
        buffer.WriteString(",")
        buffer.WriteString("\n")
	    {% endfor %}
	}
    buffer.WriteString("}")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}

{% endmacro %}

{% macro generate_vector(tree, archive, resource) %}
type {{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector) Get(i int) *{% if resource|is_multivector %}{{ resource|get_types_for_multivector(tree)|first|to_go_case }}{% else %}{{ resource|to_initializer(tree)|to_go_case }}{% endif %} {
	return &{% if resource|is_multivector %}{{ resource|get_types_for_multivector(tree)|first|to_go_case }}{% else %}{{ resource|to_initializer(tree)|to_go_case }}{% endif %}{
		internal: v.internal,
		position: i,
	}
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	intSize := binary.LittleEndian.Uint64(size)
	return int(intSize) / {% if resource|is_multivector %}{{ resource|get_types_for_multivector(tree)|first|to_go_case(false) }}{% else %}{{ resource|to_initializer(tree)|to_go_case(false) }}{% endif %}SizeInBytes
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector) GetSlice(start, end, step int) []*{% if resource|is_multivector %}{{ resource|get_types_for_multivector(tree)|first|to_go_case }}{% else %}{{ resource|to_initializer(tree)|to_go_case }}{% endif %} {
	var result []*{% if resource|is_multivector %}{{ resource|get_types_for_multivector(tree)|first|to_go_case }}{% else %}{{ resource|to_initializer(tree)|to_go_case }}{% endif %}
	
    for start <= end {
		result = append(result, &{% if resource|is_multivector %}{{ resource|get_types_for_multivector(tree)|first|to_go_case }}{% else %}{{ resource|to_initializer(tree)|to_go_case }}{% endif %}{
			internal: v.internal,
			position: start,
		})
		start += step
	}
	return result
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector) GetSizeInBytes() int {
    return v.internal.Len()
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"Vector\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size\": ")
    buffer.WriteString(strconv.Itoa(v.GetSize()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": ")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"element_types\": [")
    buffer.WriteString("\n")
    buffer.WriteString("    {")
    buffer.WriteString("\n")
    buffer.WriteString("        \"name\": \"")
    buffer.WriteString("{{ resource.referenced_structures[0].node.name|to_go_case }}")
    buffer.WriteString("\",")
    buffer.WriteString("\n")
    buffer.WriteString("        \"attributes\": [")
    buffer.WriteString("\n")
    {% for field in resource.referenced_structures[0].node.fields %}
    buffer.WriteString("            {")
    buffer.WriteString("\n")
    buffer.WriteString("                \"name\": \"")
    buffer.WriteString("{{ field.name }}")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"offset\": ")
    buffer.WriteString(strconv.Itoa({{ field.offset }}))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"width\": ")
    buffer.WriteString(strconv.Itoa({{ field.type.width }}))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"is_signed\": ")
    buffer.WriteString("{{ field.type.is_signed|lower }}")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("            },")
    buffer.WriteString("\n")
    {% endfor %}
    buffer.WriteString("        ]")
    buffer.WriteString("\n")
    buffer.WriteString("    }")
    buffer.WriteString("\n")
    buffer.WriteString("]")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}

{% endmacro %}

{% macro archive_definition(tree, archive) %}
{% for resource in archive.resources if not resource|is_bound_resource %}
{% if resource|is_instance %}
type {{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Instance struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Instance) Get() *{{ resource|to_initializer(tree)|to_go_case }} {
	return &{{ resource|to_initializer(tree)|to_go_case }}{
	    internal: v.internal,
	}
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Instance) GetSize() int {
	return 1
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Instance) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Instance) GetSizeInBytes() int {
    return v.internal.Len()
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Instance) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"Vector\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size\": ")
    buffer.WriteString(strconv.Itoa(v.GetSize()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": ")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"element_types\": [")
    buffer.WriteString("\n")
    buffer.WriteString("    {")
    buffer.WriteString("\n")
    buffer.WriteString("        \"name\": \"")
    buffer.WriteString("{{ resource.referenced_structures[0].node.name|to_go_case }}")
    buffer.WriteString("\",")
    buffer.WriteString("\n")
    buffer.WriteString("        \"attributes\": [")
    buffer.WriteString("\n")
    {% for field in resource.referenced_structures[0].node.fields %}
    buffer.WriteString("            {")
    buffer.WriteString("\n")
    buffer.WriteString("                \"name\": \"")
    buffer.WriteString("{{ field.name }}")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"offset\": ")
    buffer.WriteString(strconv.Itoa({{ field.offset }}))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"width\": ")
    buffer.WriteString(strconv.Itoa({{ field.type.width }}))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"is_signed\": ")
    buffer.WriteString("{{ field.type.is_signed|lower }}")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("            },")
    buffer.WriteString("\n")
    {% endfor %}
    buffer.WriteString("        ]")
    buffer.WriteString("\n")
    buffer.WriteString("    }")
    buffer.WriteString("\n")
    buffer.WriteString("]")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}

{% elif resource|is_vector %}
{{- generate_vector(tree, archive, resource) }}
{% elif resource|is_raw_data %}
type {{ archive.name|to_go_case }}{{ resource.name|to_go_case }}RawData struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}RawData) GetValue() []byte {
	data := make([]byte, v.GetSize())
	_, err := v.internal.ReadAt(data, 8)
	if err != nil {
		return make([]byte, 0)
	}
	return data
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}RawData) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	return int(binary.LittleEndian.Uint64(size))
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}RawData) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}RawData) GetSizeInBytes() int {
    return v.internal.Len()
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}RawData) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"RawData\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size\": ")
    buffer.WriteString(strconv.Itoa(v.GetSize()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": ")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"element_types\": []")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}

{% elif resource|is_multivector %}
{{- generate_vector(tree, archive, resource) }}

type {{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Multivector struct {
    internal flatdata.ResourceHandle
    index      *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector
	types      map[int]interface{}
    IsOptional bool
    IsOpen bool
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Multivector) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Multivector) GetSize() int {
	return v.index.GetSize()
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Multivector) GetSizeInBytes() int {
    return v.internal.Len()
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Multivector) getBucketOffset(i int) int {
    if i == v.index.GetSize() {
		return v.internal.Len() - int(flatdataPaddingSizeInBits/8)
	} 
	return int(v.index.Get(i).GetValue()) + int(flatdataOffsetSizeInBits/8)
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Multivector) Get(i int) []interface{} {
    offset := v.getBucketOffset(i)
	nextOffset := v.getBucketOffset(i + 1)
	var result []interface{}

	for offset < nextOffset {
	    elementType := flatdata.Read(v.internal, uint(offset*8), 8, false)
		offset++
		abstractElement, ok := v.types[elementType]
		if !ok {
			//TODO: How to process case, then type of element is not found?
			log.Println("Can't get type of element")
		}
		temp := 0
		switch element := abstractElement.(type) {
		{% for entry in resource|get_types_for_multivector(tree) %}
		{% if loop.index0 >= 1%}
		case *{{ entry|to_go_case }}:
			element.position = offset
            element.multivector = true
			result = append(result, element)
			temp = {{ entry|to_go_case(false) }}SizeInBytes
		{% endif %}
		{% endfor %}
		default:
			//TODO: How to react in case if it's impossible to cast?
			log.Println("Can't cast element. Type is unknown...")
		}
		offset += temp
	}
	
	return result
}

func (v *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Multivector) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"Vector\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size\": ")
    buffer.WriteString(strconv.Itoa(v.GetSize()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": ")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"element_types\": [")
    buffer.WriteString("\n")
    {% for struct in resource.referenced_structures %}
    {% if loop.index0 >= 1 %}
    buffer.WriteString("    {")
    buffer.WriteString("\n")
    buffer.WriteString("        \"name\": \"")
    buffer.WriteString("{{ resource.referenced_structures[loop.index0].node.name|to_go_case }}")
    buffer.WriteString("\",")
    buffer.WriteString("\n")
    buffer.WriteString("        \"attributes\": [")
    buffer.WriteString("\n")
    {% for field in resource.referenced_structures[loop.index0].node.fields %}
    buffer.WriteString("            {")
    buffer.WriteString("\n")
    buffer.WriteString("                \"name\": \"")
    buffer.WriteString("{{ field.name }}")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"offset\": ")
    buffer.WriteString(strconv.Itoa({{ field.offset }}))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"width\": ")
    buffer.WriteString(strconv.Itoa({{ field.type.width }}))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"is_signed\": ")
    buffer.WriteString("{{ field.type.is_signed|lower }}")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("            },")
    buffer.WriteString("\n")
    {% endfor %}
    buffer.WriteString("        ]")
    buffer.WriteString("\n")
    buffer.WriteString("    },")
    buffer.WriteString("\n")
    {% endif %}
    {% endfor %}
    buffer.WriteString("],")
    buffer.WriteString("\n")
    buffer.WriteString("    \"index_type\": {")
    buffer.WriteString("\n")
    buffer.WriteString("        \"name\": \"")
    buffer.WriteString("{{ resource.referenced_structures[0].node.name|to_go_case }}")
    buffer.WriteString("\",")
    buffer.WriteString("\n")
    buffer.WriteString("        \"attributes\": [")
    buffer.WriteString("\n")
    {% for field in resource.referenced_structures[0].node.fields %}
    buffer.WriteString("            {")
    buffer.WriteString("\n")
    buffer.WriteString("                \"name\": \"")
    buffer.WriteString("{{ field.name }}")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"offset\": ")
    buffer.WriteString(strconv.Itoa({{ field.offset }}))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"width\": ")
    buffer.WriteString(strconv.Itoa({{ field.type.width }}))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("                \"is_signed\": ")
    buffer.WriteString("{{ field.type.is_signed|lower }}")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("            }")
    buffer.WriteString("\n")
    {% endfor %}
    buffer.WriteString("        ]")
    buffer.WriteString("\n")
    buffer.WriteString("    }")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}

{% endif %}

{% endfor %}

type {{ archive.name|to_go_case }}Archive struct {
    IsOptional bool
    IsOpen bool
    {% for resource in archive.resources if not resource|is_bound_resource %}
    {% if resource|is_vector %}
    {{ resource.name|to_go_case }}Vector *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector
    {% elif resource|is_archive_resource %}
    {{ resource.name|to_go_case }}Archive *{{ resource.name|to_go_case }}Archive
    {% elif resource|is_raw_data %}
    {{ resource.name|to_go_case }}RawData *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}RawData
    {% elif resource|is_multivector %}
    {{ resource.name|to_go_case }}Multivector *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Multivector
    {% elif resource|is_instance %}
    {{ resource.name|to_go_case }}Instance *{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Instance
    {% endif %}
    {% endfor %}
}

func (v *{{ archive.name|to_go_case }}Archive) Close() {
    {% for resource in archive.resources if not resource|is_bound_resource %}
    {% if resource|is_vector %}
    if v.{{ resource.name|to_go_case }}Vector.IsOpen {
        v.{{ resource.name|to_go_case }}Vector.Close()
    }
    {% elif resource|is_archive_resource %}
    if v.{{ resource.name|to_go_case }}Archive.IsOpen {
        v.{{ resource.name|to_go_case }}Archive.Close()
    }
    {% elif resource|is_raw_data %}
    if v.{{ resource.name|to_go_case }}RawData.IsOpen {
        v.{{ resource.name|to_go_case }}RawData.Close()
    }
    {% elif resource|is_multivector %}
    if v.{{ resource.name|to_go_case }}Multivector.IsOpen {
        v.{{ resource.name|to_go_case }}Multivector.Close()
    }
    {% elif resource|is_instance %}
    if v.{{ resource.name|to_go_case }}Instance.IsOpen {
        v.{{ resource.name|to_go_case }}Instance.Close()
    }
    {% endif %}
    {% endfor %}
}

func (v *{{ archive.name|to_go_case }}Archive) GetSizeInBytes() int {
    var size int
    {% for resource in archive.resources if not resource|is_bound_resource %}
    {% if resource|is_vector %}
    if v.{{ resource.name|to_go_case }}Vector.IsOpen {
        size += v.{{ resource.name|to_go_case }}Vector.GetSizeInBytes()
    }
    {% elif resource|is_archive_resource %}
    if v.{{ resource.name|to_go_case }}Archive.IsOpen {
        size += v.{{ resource.name|to_go_case }}Archive.GetSizeInBytes()
    }
    {% elif resource|is_raw_data %}
    if v.{{ resource.name|to_go_case }}RawData.IsOpen {
        size += v.{{ resource.name|to_go_case }}RawData.GetSizeInBytes()
    }
    {% elif resource|is_multivector %}
    if v.{{ resource.name|to_go_case }}Multivector.IsOpen {
        size += v.{{ resource.name|to_go_case }}Multivector.GetSizeInBytes()
    }
    {% elif resource|is_instance %}
    if v.{{ resource.name|to_go_case }}Instance.IsOpen {
        size += v.{{ resource.name|to_go_case }}Instance.GetSizeInBytes()
    }
    {% endif %}
    {% endfor %}
    return size
}

func (v *{{ archive.name|to_go_case }}Archive) ToString() string {
    buffer := bytes.Buffer{}
    buffer.WriteString("{")
    buffer.WriteString("\n")
    buffer.WriteString("\"name\": \"")
    buffer.WriteString("{{ archive.name|to_go_case }}")
    buffer.WriteString("\"")
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"container_type\": \"Archive\",")
    buffer.WriteString("\n")
    buffer.WriteString("\"size_in_bytes\": \"")
    buffer.WriteString(strconv.Itoa(v.GetSizeInBytes()))
    buffer.WriteString(",")
    buffer.WriteString("\n")
    buffer.WriteString("\"resources\": [")
    {% for resource in archive.resources if not resource|is_bound_resource %}
    {% if resource|is_vector %}
    buffer.WriteString(v.{{ resource.name|to_go_case }}Vector.ToString())
    buffer.WriteString(",")
    buffer.WriteString("\n")
    {% elif resource|is_archive_resource %}
    buffer.WriteString(v.{{ resource.name|to_go_case }}Archive.ToString())
    buffer.WriteString(",")
    buffer.WriteString("\n")
    {% elif resource|is_raw_data %}
    buffer.WriteString(v.{{ resource.name|to_go_case }}RawData.ToString())
    buffer.WriteString(",")
    buffer.WriteString("\n")
    {% elif resource|is_multivector %}
    buffer.WriteString(v.{{ resource.name|to_go_case }}Multivector.ToString())
    buffer.WriteString(",")
    buffer.WriteString("\n")
    {% elif resource|is_instance %}
    buffer.WriteString(v.{{ resource.name|to_go_case }}Instance.ToString())
    buffer.WriteString(",")
    buffer.WriteString("\n")
    {% endif %}
    {% endfor %}
    buffer.WriteString("]")
    buffer.WriteString("\n")
    buffer.WriteString("}")
	return buffer.String()
}

func Open{{ archive.name|to_go_case }}Archive(resource flatdata.ResourceProvider) (*{{ archive.name|to_go_case }}Archive, error) {
    v := &{{ archive.name|to_go_case }}Archive{}
    // Initialize resources
	{% for resource in archive.resources if not resource|is_bound_resource%}
	{% if resource|is_archive_resource %}
	{{ resource.name|lower|to_go_case(false) }}Archive, err := Open{{ resource.name|to_go_case }}Archive(flatdata.NewFileResourceProvider(filepath.Join(resource.GetBasePath(), "{{ resource.name|lower }}/{{ resource|to_initializer(tree) }}.archive")))
	{{ resource.name|lower|to_go_case(false)}}Archive.IsOptional = {{ resource.optional|lower }}
	{{ resource.name|lower|to_go_case(false) }}Archive.IsOpen = true
	if err != nil {
	    log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        {{ resource.name|lower|to_go_case(false) }}Archive.IsOpen = false
	    } else {
		    return v, err
		}
	}
	{% else %}
	{{ resource.name|lower|to_go_case(false) }}IsOpen := true
	{{ resource.name|lower|to_go_case(false) }}Handle, schema, err := resource.GetHandle("{{ resource.name }}")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        {{ resource.name|lower|to_go_case(false) }}IsOpen = false
	    } else {
		    return v, err
		}
	}
	{% if resource|is_multivector %}
	{{ resource.name|lower|to_go_case(false) }}IndexHandle, _, err := resource.GetHandle("{{ resource.name }}_index")
	if err != nil {
	    log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        {{ resource.name|lower|to_go_case(false) }}IsOpen = false
	    } else {
		    return v, err
		}
	}
	{% endif %}
	if {{ resource.name|lower|to_go_case(false) }}IsOpen {
	    {{ resource.name|lower|to_go_case(false) }}Schema := `{{ tree.schema(resource) }}`
	    if {{ resource.name|lower|to_go_case(false) }}Schema != schema {
	        log.Println(fmt.Sprintf("Schemas didn't match, expected: \n%s\n, actual: \n%s\n", {{ resource.name|lower|to_go_case(false) }}Schema, schema))
	        return v, errors.New(flatdata.ErrorSchemaDidntMatch)
	    }
	}
	{% endif %}
	{% endfor %}
	// Add resources to archive
    {% for resource in archive.resources if not resource|is_bound_resource %}
    {% if resource|is_archive_resource %}
    v.{{ resource.name|to_go_case }}Archive = {{ resource.name|lower|to_go_case(false) }}Archive
    {% else %}
    {% if resource|is_vector %}
    v.{{ resource.name|to_go_case }}Vector = &{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector{
    {% elif resource|is_raw_data %}
    v.{{ resource.name|to_go_case }}RawData = &{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}RawData{
    {% elif resource|is_multivector %}
    v.{{ resource.name|to_go_case }}Multivector = &{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Multivector{
    {% elif resource|is_instance %}
    v.{{ resource.name|to_go_case }}Instance = &{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Instance {
    {% endif %}
        internal: {{ resource.name|lower|to_go_case(false) }}Handle,
        {% if resource|is_multivector %}
        index: &{{ archive.name|to_go_case }}{{ resource.name|to_go_case }}Vector{internal: {{ resource.name|lower|to_go_case(false) }}IndexHandle},
        types: map[int]interface{}{
        {% for entry in resource|get_types_for_multivector(tree) %}
		{% if loop.index0 >= 1%}
            {{ loop.index0 - 1 }}: &{{ entry|to_go_case }}{internal: {{ resource.name|lower|to_go_case(false) }}Handle},
		{% endif %}
		{% endfor %}
        },
        {% endif %}
        IsOptional: {{ resource.optional|lower }},
        IsOpen: {{ resource.name|lower|to_go_case(false) }}IsOpen,
    }
    {% endif %}
    {% endfor %}
	return v, nil
}

{% endmacro %}

{% for node in nodes %}
    {%- if node|is_structure %}
        {{- structure_definition(tree, node) }}
    {%- elif node|is_archive %}
        {{- archive_definition(tree, node) }}
    {% endif %}
{% endfor %}
