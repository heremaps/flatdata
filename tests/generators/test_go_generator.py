'''
 Copyright (c) 2017 HERE Europe B.V.
 See the LICENSE file in the root of this project for license details.
'''

from generator.generators.GoGenerator import GoGenerator

from .assertions import *


def test_base_generation():
    generate_and_assert_in("""namespace xyz{
        
}
    """, GoGenerator, """/////////////////////////////////////////////////////////////////////////
//    ATTENTION!
//    This code is automatically generated by flatdata generator.
//    Any modifications to this file will be lost upon next regeneration.
/////////////////////////////////////////////////////////////////////////
package xyz

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"strconv"

	"github.com/heremaps/flatdata/flatdata-go"
)

const (
    flatdataSizeInBits uint = 64
)""")


def test_constants_are_declared_correctly():
    generate_and_assert_in("""
        namespace n{
        const i8 foo = 17;
        const u16 bar = 0x42;
        }
    """, GoGenerator, """
    Bar uint16 = 0x42
    Foo int8 = 17
    """)


def test_structures_are_declared_correctly():
    expected_lines = [
        """sSizeInBytes = 3""",
        """type S struct {
    internal flatdata.ResourceHandle
	position int
}""",
        """func (v *S) GetF0() uint8 {
    sSizeInBits  := uint(18)
    sF0Size         := uint(3)
    sF0Offset       := uint(0)
    sF0IsSigned     := false
    b := flatdata.Read(v.internal, flatdataSizeInBits+(sSizeInBits*uint(v.position))+sF0Offset, sF0Size, sF0IsSigned)
    return uint8(b)
}""",
        """func (v *S) GetF1() uint16 {
    sSizeInBits  := uint(18)
    sF1Size         := uint(15)
    sF1Offset       := uint(3)
    sF1IsSigned     := false
    b := flatdata.Read(v.internal, flatdataSizeInBits+(sSizeInBits*uint(v.position))+sF1Offset, sF1Size, sF1IsSigned)
    return uint16(b)
}""",
        """func (v *S) ToString() string {"""
    ]

    generate_and_assert_in("""
        namespace n{
        struct S {
            f0 : u8 : 3;
            f1 : u16 : 15;
        }
        }
    """, GoGenerator, *expected_lines)


def test_archives_are_declared_correctly():
    expected_lines = [
        """sSizeInBytes = 1""",
        """type S struct {
    internal flatdata.ResourceHandle
	position int
}

func (v *S) GetF0() uint8 {
    sSizeInBits  := uint(3)
    sF0Size         := uint(3)
    sF0Offset       := uint(0)
    sF0IsSigned     := false
    b := flatdata.Read(v.internal, flatdataSizeInBits+(sSizeInBits*uint(v.position))+sF0Offset, sF0Size, sF0IsSigned)
    return uint8(b)
}""",
        """func (v *S) ToString() string {""",
        """type AR0Instance struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *AR0Instance) Get() *S {
	return &S{
	    internal: v.internal,
	}
}

func (v *AR0Instance) GetSize() int {
	return 1
}

func (v *AR0Instance) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *AR0Instance) GetSizeInBytes() int {
    return v.internal.Len()
}""",
        """type AArchive struct {
    IsOptional bool
    IsOpen bool
    R0Instance *AR0Instance
}

func (v *AArchive) Close() {
    if v.R0Instance.IsOpen {
        v.R0Instance.Close()
    }
}

func (v *AArchive) GetSizeInBytes() int {
    var size int
    if v.R0Instance.IsOpen {
        size += v.R0Instance.GetSizeInBytes()
    }
    return size
}""",
        """func OpenAArchive(resource flatdata.ResourceProvider) (*AArchive, error) {
    v := &AArchive{}
    // Initialize resources
	r0IsOpen := true
	r0Handle, schema, err := resource.GetHandle("r0")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        r0IsOpen = false
	    } else {
		    return v, err
		}
	}""",
        """// Add resources to archive
    v.R0Instance = &AR0Instance {
        internal: r0Handle,
        IsOptional: false,
        IsOpen: r0IsOpen,
    }
	return v, nil
}"""
    ]

    generate_and_assert_in("""
    namespace n{
    struct S {
        f0 : u8 : 3;
    }
    archive A {
        r0 : S;
    }
    }""", GoGenerator, *expected_lines)


def test_vector_resource_is_declared_correctly():
    expected_lines = [
        """tSizeInBytes = 1""",
        """type T struct {
    internal flatdata.ResourceHandle
	position int
}

func (v *T) GetF0() uint8 {
    tSizeInBits  := uint(3)
    tF0Size         := uint(3)
    tF0Offset       := uint(0)
    tF0IsSigned     := false
    b := flatdata.Read(v.internal, flatdataSizeInBits+(tSizeInBits*uint(v.position))+tF0Offset, tF0Size, tF0IsSigned)
    return uint8(b)
}""",
        """func (v *T) ToString() string {""",
        """type AVectorResourceVector struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *AVectorResourceVector) Get(i int) *T {
	return &T{
		internal: v.internal,
		position: i,
	}
}

func (v *AVectorResourceVector) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	intSize := binary.LittleEndian.Uint64(size)
	return int(intSize) / tSizeInBytes
}

func (v *AVectorResourceVector) GetSlice(start, end, step int) []*T {
	var result []*T	
	for start <= end {
		result = append(result, &T{
			internal: v.internal,
			position: start,
		})
		start += step
	}
	return result
}

func (v *AVectorResourceVector) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *AVectorResourceVector) GetSizeInBytes() int {
    return v.internal.Len()
}""",
        """type AArchive struct {
    IsOptional bool
    IsOpen bool
    VectorResourceVector *AVectorResourceVector
}

func (v *AArchive) Close() {
    if v.VectorResourceVector.IsOpen {
        v.VectorResourceVector.Close()
    }
}

func (v *AArchive) GetSizeInBytes() int {
    var size int
    if v.VectorResourceVector.IsOpen {
        size += v.VectorResourceVector.GetSizeInBytes()
    }
    return size
}""",
        """func OpenAArchive(resource flatdata.ResourceProvider) (*AArchive, error) {
    v := &AArchive{}
    // Initialize resources
	vectorResourceIsOpen := true
	vectorResourceHandle, schema, err := resource.GetHandle("vector_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        vectorResourceIsOpen = false
	    } else {
		    return v, err
		}
	}""",
        """// Add resources to archive
    v.VectorResourceVector = &AVectorResourceVector{
        internal: vectorResourceHandle,
        IsOptional: false,
        IsOpen: vectorResourceIsOpen,
    }
	return v, nil
}"""
    ]

    generate_and_assert_in("""
    namespace n{
    struct T {
        f0 : u8 : 3;
    }
    archive A {
        vector_resource : vector< T >;
    }
    }""", GoGenerator, *expected_lines)


def test_multi_vector_resource_is_declared_correctly():
    expected_lines = [
        """indexType33SizeInBytes = 5
    uSizeInBytes = 1
    tSizeInBytes = 1""",
        """type IndexType33 struct {
    internal flatdata.ResourceHandle
	position int
}

func (v *IndexType33) GetValue() uint64 {
    indexType33SizeInBits  := uint(33)
    indexType33ValueSize         := uint(33)
    indexType33ValueOffset       := uint(0)
    indexType33ValueIsSigned     := false
    b := flatdata.Read(v.internal, flatdataSizeInBits+(indexType33SizeInBits*uint(v.position))+indexType33ValueOffset, indexType33ValueSize, indexType33ValueIsSigned)
    return uint64(b)
}""",
        """type U struct {
    internal flatdata.ResourceHandle
	position int
}

func (v *U) GetF0() uint8 {
    uSizeInBits  := uint(3)
    uF0Size         := uint(3)
    uF0Offset       := uint(0)
    uF0IsSigned     := false
    b := flatdata.Read(v.internal, flatdataSizeInBits+(uSizeInBits*uint(v.position))+uF0Offset, uF0Size, uF0IsSigned)
    return uint8(b)
}""",
        """type T struct {
    internal flatdata.ResourceHandle
	position int
}

func (v *T) GetF0() uint8 {
    tSizeInBits  := uint(3)
    tF0Size         := uint(3)
    tF0Offset       := uint(0)
    tF0IsSigned     := false
    b := flatdata.Read(v.internal, flatdataSizeInBits+(tSizeInBits*uint(v.position))+tF0Offset, tF0Size, tF0IsSigned)
    return uint8(b)
}""",
        """type AMultivectorResourceVector struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *AMultivectorResourceVector) Get(i int) *IndexType33 {
	return &IndexType33{
		internal: v.internal,
		position: i,
	}
}

func (v *AMultivectorResourceVector) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	intSize := binary.LittleEndian.Uint64(size)
	return int(intSize) / indexType33SizeInBytes
}

func (v *AMultivectorResourceVector) GetSlice(start, end, step int) []*IndexType33 {
	var result []*IndexType33	
	for start <= end {
		result = append(result, &IndexType33{
			internal: v.internal,
			position: start,
		})
		start += step
	}
	return result
}

func (v *AMultivectorResourceVector) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *AMultivectorResourceVector) GetSizeInBytes() int {
    return v.internal.Len()
}""",
        """type AMultivectorResourceMultivector struct {
    internal flatdata.ResourceHandle
    index      *AMultivectorResourceVector
	types      map[int]interface{}
    IsOptional bool
    IsOpen bool
}

func (v *AMultivectorResourceMultivector) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *AMultivectorResourceMultivector) GetSize() int {
	return v.index.GetSize()
}

func (v *AMultivectorResourceMultivector) GetSizeInBytes() int {
    return v.internal.Len()
}

func (v *AMultivectorResourceMultivector) getBucketOffset(i int) int {
	return int(v.index.Get(i).GetValue()) + int(flatdataSizeInBits / 8)
}

func (v *AMultivectorResourceMultivector) Get(i int) []interface{} {
    offset := v.getBucketOffset(i)
	nextOffset := v.getBucketOffset(i + 1)
	var result []interface{}

	for offset < nextOffset {
	    elementType := flatdata.Read(v.internal, uint(offset*8), 8, false)
		offset++
		abstractElement, ok := v.types[elementType]
		if !ok {
			//TODO: How to process case, then type of element is not found?
			log.Println("Can't get type of element")
		}
		temp := 0
		switch element := abstractElement.(type) {
		case *T:
			element.position = offset
			result = append(result, element)
			temp = tSizeInBytes
		case *U:
			element.position = offset
			result = append(result, element)
			temp = uSizeInBytes
		default:
			//TODO: How to react in case if it's impossible to cast?
			log.Println("Can't cast element. Type is unknown...")
		}
		offset += temp
	}
	
	return result
}""",
        """type AArchive struct {
    IsOptional bool
    IsOpen bool
    MultivectorResourceMultivector *AMultivectorResourceMultivector
}

func (v *AArchive) Close() {
    if v.MultivectorResourceMultivector.IsOpen {
        v.MultivectorResourceMultivector.Close()
    }
}

func (v *AArchive) GetSizeInBytes() int {
    var size int
    if v.MultivectorResourceMultivector.IsOpen {
        size += v.MultivectorResourceMultivector.GetSizeInBytes()
    }
    return size
}""",
        """func OpenAArchive(resource flatdata.ResourceProvider) (*AArchive, error) {
    v := &AArchive{}
    // Initialize resources
	multivectorResourceIsOpen := true
	multivectorResourceHandle, schema, err := resource.GetHandle("multivector_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        multivectorResourceIsOpen = false
	    } else {
		    return v, err
		}
	}
	multivectorResourceIndexHandle, _, err := resource.GetHandle("multivector_resource_index")
	if err != nil {
	    log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        multivectorResourceIsOpen = false
	    } else {
		    return v, err
		}
	}""",
        """v.MultivectorResourceMultivector = &AMultivectorResourceMultivector{
        internal: multivectorResourceHandle,
        index: &AMultivectorResourceVector{internal: multivectorResourceIndexHandle},
        types: map[int]interface{}{
            0: &T{internal: multivectorResourceHandle},
            1: &U{internal: multivectorResourceHandle},
        },
        IsOptional: false,
        IsOpen: multivectorResourceIsOpen,
    }
	return v, nil
}"""
    ]

    generate_and_assert_in("""
    namespace n{
    struct U {
        f0 : u8 : 3;
    }
    struct T {
        f0 : u8 : 3;
    }
    archive A {
        multivector_resource : multivector< 33, T, U >;
    }
    }""", GoGenerator, *expected_lines)


def test_raw_data_resource_is_declared_correctly():
    expected_lines = [
        """type ARawDataResourceRawData struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *ARawDataResourceRawData) GetValue() []byte {
	data := make([]byte, v.GetSize())
	_, err := v.internal.ReadAt(data, 8)
	if err != nil {
		return make([]byte, 0)
	}
	return data
}

func (v *ARawDataResourceRawData) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	return int(binary.LittleEndian.Uint64(size))
}

func (v *ARawDataResourceRawData) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *ARawDataResourceRawData) GetSizeInBytes() int {
    return v.internal.Len()
}""",
        """type AArchive struct {
    IsOptional bool
    IsOpen bool
    RawDataResourceRawData *ARawDataResourceRawData
}

func (v *AArchive) Close() {
    if v.RawDataResourceRawData.IsOpen {
        v.RawDataResourceRawData.Close()
    }
}

func (v *AArchive) GetSizeInBytes() int {
    var size int
    if v.RawDataResourceRawData.IsOpen {
        size += v.RawDataResourceRawData.GetSizeInBytes()
    }
    return size
}""",
        """func OpenAArchive(resource flatdata.ResourceProvider) (*AArchive, error) {
    v := &AArchive{}
    // Initialize resources
	rawDataResourceIsOpen := true
	rawDataResourceHandle, schema, err := resource.GetHandle("raw_data_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        rawDataResourceIsOpen = false
	    } else {
		    return v, err
		}
	}""",
        """v.RawDataResourceRawData = &ARawDataResourceRawData{
        internal: rawDataResourceHandle,
        IsOptional: false,
        IsOpen: rawDataResourceIsOpen,
    }
	return v, nil
}"""
    ]

    generate_and_assert_in("""
    namespace n{
    archive A {
        raw_data_resource : raw_data;
    }
    }""", GoGenerator, *expected_lines)


def test_structures_are_defined_correctly():
    expected_lines = [
        """sSizeInBytes = 3""",
        """type S struct {
    internal flatdata.ResourceHandle
	position int
}

func (v *S) GetF0() uint8 {
    sSizeInBits  := uint(20)
    sF0Size         := uint(7)
    sF0Offset       := uint(0)
    sF0IsSigned     := false
    b := flatdata.Read(v.internal, flatdataSizeInBits+(sSizeInBits*uint(v.position))+sF0Offset, sF0Size, sF0IsSigned)
    return uint8(b)
}

func (v *S) GetF1() int16 {
    sSizeInBits  := uint(20)
    sF1Size         := uint(13)
    sF1Offset       := uint(7)
    sF1IsSigned     := true
    b := flatdata.Read(v.internal, flatdataSizeInBits+(sSizeInBits*uint(v.position))+sF1Offset, sF1Size, sF1IsSigned)
    return int16(b)
}"""
    ]

    generate_and_assert_in("""
    namespace n{
    struct S {
        f0 : u8 : 7;
        f1 : i16 : 13;
    }
    }
    """, GoGenerator, *expected_lines)


def test_archives_are_defined_correctly():
    expected_lines = [
        """type ARawDataResourceRawData struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *ARawDataResourceRawData) GetValue() []byte {
	data := make([]byte, v.GetSize())
	_, err := v.internal.ReadAt(data, 8)
	if err != nil {
		return make([]byte, 0)
	}
	return data
}

func (v *ARawDataResourceRawData) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	return int(binary.LittleEndian.Uint64(size))
}

func (v *ARawDataResourceRawData) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *ARawDataResourceRawData) GetSizeInBytes() int {
    return v.internal.Len()
}""",
        """type AArchive struct {
    IsOptional bool
    IsOpen bool
    RawDataResourceRawData *ARawDataResourceRawData
}

func (v *AArchive) Close() {
    if v.RawDataResourceRawData.IsOpen {
        v.RawDataResourceRawData.Close()
    }
}

func (v *AArchive) GetSizeInBytes() int {
    var size int
    if v.RawDataResourceRawData.IsOpen {
        size += v.RawDataResourceRawData.GetSizeInBytes()
    }
    return size
}""",
        """func OpenAArchive(resource flatdata.ResourceProvider) (*AArchive, error) {
    v := &AArchive{}
    // Initialize resources
	rawDataResourceIsOpen := true
	rawDataResourceHandle, schema, err := resource.GetHandle("raw_data_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        rawDataResourceIsOpen = false
	    } else {
		    return v, err
		}
	}""",
        """// Add resources to archive
    v.RawDataResourceRawData = &ARawDataResourceRawData{
        internal: rawDataResourceHandle,
        IsOptional: false,
        IsOpen: rawDataResourceIsOpen,
    }
	return v, nil
}"""
    ]

    generate_and_assert_in("""
    namespace n{
    archive A {
        raw_data_resource : raw_data;
    }
    }
    """, GoGenerator, *expected_lines)


def test_optional_resource_is_declared_correctly():
    expected_lines = [
        """type ARawDataResourceRawData struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *ARawDataResourceRawData) GetValue() []byte {
	data := make([]byte, v.GetSize())
	_, err := v.internal.ReadAt(data, 8)
	if err != nil {
		return make([]byte, 0)
	}
	return data
}

func (v *ARawDataResourceRawData) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	return int(binary.LittleEndian.Uint64(size))
}

func (v *ARawDataResourceRawData) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *ARawDataResourceRawData) GetSizeInBytes() int {
    return v.internal.Len()
}""",
        """type AArchive struct {
    IsOptional bool
    IsOpen bool
    RawDataResourceRawData *ARawDataResourceRawData
}

func (v *AArchive) Close() {
    if v.RawDataResourceRawData.IsOpen {
        v.RawDataResourceRawData.Close()
    }
}

func (v *AArchive) GetSizeInBytes() int {
    var size int
    if v.RawDataResourceRawData.IsOpen {
        size += v.RawDataResourceRawData.GetSizeInBytes()
    }
    return size
}""",
        """func OpenAArchive(resource flatdata.ResourceProvider) (*AArchive, error) {
    v := &AArchive{}
    // Initialize resources
	rawDataResourceIsOpen := true
	rawDataResourceHandle, schema, err := resource.GetHandle("raw_data_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        rawDataResourceIsOpen = false
	    } else {
		    return v, err
		}
	}""",
        """v.RawDataResourceRawData = &ARawDataResourceRawData{
        internal: rawDataResourceHandle,
        IsOptional: true,
        IsOpen: rawDataResourceIsOpen,
    }
	return v, nil
}"""
    ]

    generate_and_assert_in("""
    namespace n{
    archive A {
        @optional
        raw_data_resource : raw_data;
    }
    }""", GoGenerator, *expected_lines)


def test_optional_resource_is_declared_correctly():
    expected_lines = [
        """type ARawDataResourceRawData struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *ARawDataResourceRawData) GetValue() []byte {
	data := make([]byte, v.GetSize())
	_, err := v.internal.ReadAt(data, 8)
	if err != nil {
		return make([]byte, 0)
	}
	return data
}

func (v *ARawDataResourceRawData) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	return int(binary.LittleEndian.Uint64(size))
}

func (v *ARawDataResourceRawData) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *ARawDataResourceRawData) GetSizeInBytes() int {
    return v.internal.Len()
}""",
        """type AArchive struct {
    IsOptional bool
    IsOpen bool
    RawDataResourceRawData *ARawDataResourceRawData
}

func (v *AArchive) Close() {
    if v.RawDataResourceRawData.IsOpen {
        v.RawDataResourceRawData.Close()
    }
}

func (v *AArchive) GetSizeInBytes() int {
    var size int
    if v.RawDataResourceRawData.IsOpen {
        size += v.RawDataResourceRawData.GetSizeInBytes()
    }
    return size
}""",
        """func OpenAArchive(resource flatdata.ResourceProvider) (*AArchive, error) {
    v := &AArchive{}
    // Initialize resources
	rawDataResourceIsOpen := true
	rawDataResourceHandle, schema, err := resource.GetHandle("raw_data_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        rawDataResourceIsOpen = false
	    } else {
		    return v, err
		}
	}""",
        """v.RawDataResourceRawData = &ARawDataResourceRawData{
        internal: rawDataResourceHandle,
        IsOptional: true,
        IsOpen: rawDataResourceIsOpen,
    }
	return v, nil
}"""
    ]

    generate_and_assert_in("""
    namespace n{
    archive A {
        @optional
        raw_data_resource : raw_data;
    }
    }""", GoGenerator, *expected_lines)


def test_optional_resource_is_declared_correctly():
    expected_lines = [
        """type ARawDataResourceRawData struct {
    internal flatdata.ResourceHandle
    IsOptional bool
    IsOpen bool
}

func (v *ARawDataResourceRawData) GetValue() []byte {
	data := make([]byte, v.GetSize())
	_, err := v.internal.ReadAt(data, 8)
	if err != nil {
		return make([]byte, 0)
	}
	return data
}

func (v *ARawDataResourceRawData) GetSize() int {
	size := make([]byte, 8)
	_, err := v.internal.ReadAt(size, 0)
	if err != nil {
		return 0
	}
	return int(binary.LittleEndian.Uint64(size))
}

func (v *ARawDataResourceRawData) Close() {
    v.internal.Close()
    v.IsOpen = false
}

func (v *ARawDataResourceRawData) GetSizeInBytes() int {
    return v.internal.Len()
}""",
        """type AArchive struct {
    IsOptional bool
    IsOpen bool
    RawDataResourceRawData *ARawDataResourceRawData
}

func (v *AArchive) Close() {
    if v.RawDataResourceRawData.IsOpen {
        v.RawDataResourceRawData.Close()
    }
}

func (v *AArchive) GetSizeInBytes() int {
    var size int
    if v.RawDataResourceRawData.IsOpen {
        size += v.RawDataResourceRawData.GetSizeInBytes()
    }
    return size
}""",
        """func OpenAArchive(resource flatdata.ResourceProvider) (*AArchive, error) {
    v := &AArchive{}
    // Initialize resources
	rawDataResourceIsOpen := true
	rawDataResourceHandle, schema, err := resource.GetHandle("raw_data_resource")
	if err != nil {
        log.Println(err)
	    if err.Error() == flatdata.ErrorCantAccessResource {
	        rawDataResourceIsOpen = false
	    } else {
		    return v, err
		}
	}""",
        """v.RawDataResourceRawData = &ARawDataResourceRawData{
        internal: rawDataResourceHandle,
        IsOptional: true,
        IsOpen: rawDataResourceIsOpen,
    }
	return v, nil
}"""
    ]

    generate_and_assert_in("""
    namespace n{
    archive A {
        @optional
        raw_data_resource : raw_data;
    }
    }""", GoGenerator, *expected_lines)


def test_check_schema_validation_generation():
    # TODO: How to properly put a whole code fragment?
    expected_lines = [
        "if vectorResourceIsOpen {",
        "vectorResourceSchema := ",
        "if vectorResourceSchema != schema {"
    ]

    generate_and_assert_in("""
    namespace n{
    struct T {
        f0 : u8 : 3;
    }
    archive A {
        vector_resource : vector< T >;
    }
    }
    """, GoGenerator, *expected_lines)


def test_check_tostring_generation():
    expected_lines = [
        "func (v *IndexType32) ToString() string {",
        "func (v *T) ToString() string {",
        "func (v *AVectorResourceVector) ToString() string {",
        "func (v *ARawDataResourceRawData) ToString() string {",
        "func (v *AMultivectorResourceVector) ToString() string {",
        "func (v *AMultivectorResourceMultivector) ToString() string {",
        "func (v *AInstanceResourceInstance) ToString() string {",
        "func (v *AArchive) ToString() string {"
    ]

    generate_and_assert_in("""namespace xyz{
    struct T {
        f0 : u8 : 3;
    }
    archive A {
        vector_resource : vector< T >;
        raw_data_resource : raw_data;
        multivector_resource : multivector< 32, T >;
        instance_resource : T;
    }
}""", GoGenerator, *expected_lines)


def test_import_added_for_archive_resource():
    generate_and_assert_in("""namespace xyz{
    struct T {
        f0 : u8 : 3;
    }
    archive A {
        vector_resource : vector< T >;
    }
    archive B {
        archive_resource : archive A;
    }
}""", GoGenerator, "\"path/filepath\"")