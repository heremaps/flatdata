/**
 * Copyright (c) 2017 HERE Europe B.V.
 * See the LICENSE file in the root of this project for license details.
 */

/**
 * A simple example, which serializes the first 30 fibonacci numbers, and deserializes them.
 */

#include "fibonacci.hpp"  // generated by flatdata from fibonacci.flatdata
#include <flatdata/flatdata.h>
#include <iostream>
#include <string>

int
write( const char* folder )
{
    auto storage = flatdata::FileResourceStorage::create( folder );      // create storage
    auto builder = fib::FibonacciBuilder::open( std::move( storage ) );  // create builder
    auto numbers = builder.start_numbers( );                             // start writing numbers

    uint64_t a = 1;
    uint64_t b = 1;
    for ( size_t n = 0; n < 30; ++n )
    {
        fib::NumberMutator number = numbers.grow( );  // get next element to write
        number.value = a;                             // set data of the element

        uint64_t c = a + b;
        a = b;
        b = c;
    }
    numbers.close( );  // flush not yet flushed data to disk

    return 0;
}

int
read( const char* folder )
{
    auto storage = flatdata::FileResourceStorage::create( folder );  // open storage
    auto archive = fib::Fibonacci::open( std::move( storage ) );     // create archive
    for ( fib::Number number : archive.numbers( ) )                  // iterate through numbers
    {
        // Note: number is just a handle to memory. We can copy it without copying the data itself.
        std::cout << number.value.as< uint64_t >( ) << " ";
    }
    std::cout << std::endl;
    return 0;
}

static const char* USAGE = "USAGE: fibonacci <write|read> <folder>";

int
main( int argc, char const* argv[] )
{
    if ( argc != 3 )
    {
        std::cerr << USAGE << std::endl;
        return 1;
    }

    std::string verb( argv[ 1 ] );
    try
    {
        if ( verb == "write" )
        {
            return write( argv[ 2 ] );
        }
        else if ( verb == "read" )
        {
            return read( argv[ 2 ] );
        }
        else
        {
            std::cerr << USAGE << std::endl;
            return 1;
        }
    }
    catch ( std::runtime_error err )
    {
        std::cerr << "Error: " << err.what( ) << std::endl;
    }

    return 0;
}
