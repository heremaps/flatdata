/**
 * Copyright (c) 2017 HERE Europe B.V.
 * See the LICENSE file in the root of this project for license details.
 */

/**
 * A simple example, which serializes a part of parabola's graph, and deserializes it.
 */

#include "graph.hpp"  // generated by flatdata from graph.flatdata
#include <flatdata/flatdata.h>
#include <iostream>
#include <string>

int
write( const char* folder )
{
    auto storage = flatdata::FileResourceStorage::create( folder );    // create storage
    auto builder = graph::GraphBuilder::open( std::move( storage ) );  // create builder

    // serialize vertices from memory at once
    static const int NUM_VERTICES = 10;                          // populate a flatdata
    flatdata::Vector< graph::Vertex > vertices( NUM_VERTICES );  // vector with 10
    for ( int i = 0; i < NUM_VERTICES; ++i )
    {
        // vertices on a parabola
        graph::VertexMutator v = vertices[ i ];
        v.x = i;
        v.y = i * i;
    }
    builder.set_vertices( vertices );  // serialize vertices

    // serialize edges iteratively in-place
    static const int NUM_EDGES = NUM_VERTICES - 1;  // populate a flatdata
    auto edges = builder.start_edges( );            // vector in-place with
    for ( int i = 0; i < NUM_EDGES; ++i )
    {
        // 9 edges connecting the consecutive vertices
        graph::EdgeMutator e = edges.grow( );
        e.from_ref = i;
        e.to_ref = i + 1;
    }
    edges.close( );  // serialize edges
    return 0;
}

int
read( const char* folder )
{
    auto storage = flatdata::FileResourceStorage::create( folder );
    auto graph = graph::Graph::open( std::move( storage ) );

    // read vertices
    std::cout << "Num vertices: " << graph.vertices( ).size( ) << std::endl;
    for ( graph::Vertex v : graph.vertices( ) )
    {
        std::cerr << "Vertex(" << v.x << ", " << v.y << ")" << std::endl;
    }

    // read edges
    std::cout << "Num edges: " << graph.edges( ).size( ) << std::endl;
    for ( graph::Edge e : graph.edges( ) )
    {
        std::cerr << "Edge(" << e.from_ref << " -> " << e.to_ref << ")" << std::endl;
    }

    return 0;
}

static const char* USAGE = "USAGE: graph <write|read> <folder>";

int
main( int argc, char const* argv[] )
{
    if ( argc != 3 )
    {
        std::cerr << USAGE << std::endl;
        return 1;
    }

    std::string verb( argv[ 1 ] );
    try
    {
        if ( verb == "write" )
        {
            return write( argv[ 2 ] );
        }
        else if ( verb == "read" )
        {
            return read( argv[ 2 ] );
        }
        else
        {
            std::cerr << USAGE << std::endl;
            return 1;
        }
    }
    catch ( const std::runtime_error& err )
    {
        std::cerr << "Error: " << err.what( ) << std::endl;
    }

    return 0;
}
