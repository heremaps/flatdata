namespace n {
namespace internal
{
    const char* const U8__schema__ = R"schema(namespace n {
struct U8
{
    f : u8 : 8;
}
}

)schema";
}

template< template < typename, int, int, int > class Member >
inline
U8Template< Member >::U8Template( )
: _data( Member< uint32_t, 0, 0, 0 >{nullptr} )
{
}

template< template < typename, int, int, int > class Member >
inline
U8Template< Member >::U8Template( StreamType data )
: _data( Member< uint32_t, 0, 0, 0 >{data} )
{
}

template< template < typename, int, int, int > class Member >
inline
U8Template< Member >::operator bool( ) const
{
return _data.data != nullptr;
}

template< template < typename, int, int, int > class Member >
inline
typename U8Template< Member >::StreamType U8Template< Member >::data( ) const { return _data.data; }

template< template < typename, int, int, int > class Member >
inline
std::string U8Template< Member >::schema( ) { return internal::U8__schema__; }

template< template < typename, int, int, int > class Member >
inline
std::string U8Template< Member >::name( ) { return "U8"; }

template< template < typename, int, int, int > class Member >
inline
constexpr size_t U8Template< Member >::size_in_bytes( ) { return 1; }

template< template < typename, int, int, int > class Member >
inline
bool U8Template< Member >::operator==( const U8Template& other ) const
{
    for ( size_t i = 0; i < size_in_bytes( ); i++ )
    {
        if ( _data.data[ i ] != other._data.data[ i ] )
        {
            return false;
        }
    }
    return true;
}

template< template < typename, int, int, int > class Member >
inline
bool U8Template< Member >::operator!=( const U8Template& other ) const
{
    return !( *this == other );
}

template< template < typename, int, int, int > class Member >
inline
bool U8Template< Member >::operator<( const U8Template& other ) const
{
return
    f < other.f;
}

template< template < typename, int, int, int > class Member >
inline
U8Template< Member >::operator U8Template< flatdata::Reader >( ) const
{
    return U8Template< flatdata::Reader >( _data.data );
}

template< template < typename, int, int, int > class Member >
inline
std::string U8Template< Member >::to_string( ) const
{
    std::ostringstream ss;
    ss << "U8 {" << std::endl <<
    "    f : " << +f << "," << std::endl
    << "}"
;
    return ss.str( );
}

template< template < typename, int, int, int > class Member >
inline
std::string U8Template< Member >::describe( size_t /*unused*/ ) const
{
    std::ostringstream ss;
    if( this->operator bool( ) )
    {
        ss << "Structure of size " << size_in_bytes( );
    }
    else
    {
        ss << "Uninitialized Structure " << name();
    }
    return ss.str( );
}
} // namespace n
