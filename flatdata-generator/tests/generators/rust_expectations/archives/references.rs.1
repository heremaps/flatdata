// Do not edit: This code was generated by flatdata's generator.
#[allow(missing_docs)]
pub mod n {
#[repr(transparent)]
#[derive(Clone)]
pub struct S {
    data: [u8; 4],
}

impl S {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 4]}
    }
}

impl flatdata::Struct for S {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 4]}
    }

    const SIZE_IN_BYTES: usize = 4;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl S {
    pub fn new( ) -> Self {
        Self{data : [0; 4]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 4]) -> &Self {
        // Safety: This is safe since S is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 4]) -> &mut Self {
        // Safety: This is safe since S is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 4 {
            assert_eq!(data.len(), 4);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 4];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 4 {
            assert_eq!(data.len(), 4);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 4];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 4] {
        &self.data
    }
}

impl Default for S {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for S {}

impl S {
    #[inline]
    pub fn x(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 0, 32);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

}

impl std::fmt::Debug for S {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("S")
            .field("x", &self.x())
            .finish()
    }
}

impl std::cmp::PartialEq for S {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.x() == other.x()     }
}

impl S {
    #[inline]
    #[allow(missing_docs)]
    pub fn set_x(&mut self, value: u32) {
        flatdata_write_bytes!(u32; value, self.data, 0, 32)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &S) {
        self.set_x(other.x());
    }
}
#[repr(transparent)]
#[derive(Clone)]
pub struct R {
    data: [u8; 2],
}

impl R {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 2]}
    }
}

impl flatdata::Struct for R {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 2]}
    }

    const SIZE_IN_BYTES: usize = 2;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl R {
    pub fn new( ) -> Self {
        Self{data : [0; 2]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 2]) -> &Self {
        // Safety: This is safe since R is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 2]) -> &mut Self {
        // Safety: This is safe since R is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 2 {
            assert_eq!(data.len(), 2);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 2];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 2 {
            assert_eq!(data.len(), 2);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 2];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 2] {
        &self.data
    }
}

impl Default for R {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for R {}

impl R {
    #[inline]
    pub fn ref_(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 0, 8);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    #[inline]
    pub fn ref2(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 8, 4);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

}

impl std::fmt::Debug for R {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("R")
            .field("ref_", &self.ref_())
            .field("ref2", &self.ref2())
            .finish()
    }
}

impl std::cmp::PartialEq for R {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.ref_() == other.ref_() &&        self.ref2() == other.ref2()     }
}

impl R {
    #[inline]
    #[allow(missing_docs)]
    pub fn set_ref_(&mut self, value: u32) {
        flatdata_write_bytes!(u32; value, self.data, 0, 8)
    }

    #[inline]
    #[allow(missing_docs)]
    pub fn set_ref2(&mut self, value: u32) {
        flatdata_write_bytes!(u32; value, self.data, 8, 4)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &R) {
        self.set_ref_(other.ref_());
        self.set_ref2(other.ref2());
    }
}


/// Enum for read-only heterogeneous access to elements in a
/// bucket of the [`multilist1`] resource.
///
/// [`multilist1`]: struct.Archive{.n.A}.html#method.multilist1
#[derive(Clone, PartialEq)]
pub enum Multilist1Ref<'a> {
    #[allow(missing_docs)]
    S(&'a super::n::S),}

impl<'a> ::std::fmt::Debug for Multilist1Ref<'a> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            Multilist1Ref::S(ref inner) => write!(f, "{:?}", inner),
        }
    }
}

impl<'a> flatdata::VariadicRef for Multilist1Ref<'a> {
    #[inline]
    fn size_in_bytes(&self) -> usize {
        match *self {
            Multilist1Ref::S(_) => <super::n::S as flatdata::Struct>::SIZE_IN_BYTES,
        }
    }
}

/// Builder of buckets in the [`multilist1`] resource.
///
/// Refers to a single bucket in the [`multilist1`] multivector and
/// provides methods for adding heterogeneous data to the bucket.
///
/// [`multilist1`]: struct.Archive{.n.A}.html#method.multilist1
pub struct Multilist1Builder<'a> {
    data: &'a mut Vec<u8>
}

impl<'a> Multilist1Builder<'a> {
    /// Adds data of the type [`S`] to the bucket.
    ///
    /// [`S`]: struct.S.html
    #[inline]
    pub fn add_s<'b>(&'b mut self) -> &'b mut super::n::S {
        let old_len = self.data.len();
        let increment = 1 + <super::n::S as flatdata::Struct>::SIZE_IN_BYTES;
        self.data.resize(old_len + increment, 0);
        self.data[old_len] = 0;
        let slice = &mut self.data[1 + old_len..];
        super::n::S::from_bytes_slice_mut(slice).expect("Logic error: Cannot create super::n::S from slice")
    }
}

/// Variadic struct attached to the [`multilist1`] archive resource.
///
/// It unifies the following data types:
//
/// * [`S`]
///
/// ## Access pattern
///
/// This structure is used as a template parameter in [`multilist1`] multivector/
/// multiarray view. It does not contain any data, instead it references
///
/// * [`Multilist1Ref`] for the read-only heterogeneous access, and
/// * [`Multilist1Builder`] for the mutable builder pattern access.
///
/// [`multilist1`]: struct.Archive{.n.A}.html#method.multilist1
/// [`Multilist1Ref`]: enum.Multilist1Ref.html
/// [`Multilist1Builder`]: struct.Multilist1Builder.html
/// [`S`]: struct.S.html
#[derive(Clone)]
pub struct Multilist1 {}

impl flatdata::VariadicIndex for Multilist1 {
    type Index = super::_builtin::multivector::IndexType32;
}

impl<'a> flatdata::VariadicStruct<'a> for Multilist1 {
    type Item = Multilist1Ref<'a>;

    #[inline]
    fn create(index: flatdata::TypeIndex, data: &'a [u8]) -> Self::Item
    {
        match index {
                0 => Multilist1Ref::S(super::n::S::from_bytes_slice(&data).expect("Corrupted data")),
            _ => panic!("invalid type index {} for variadic type Multilist1Ref", index),
        }
    }

    type ItemMut = Multilist1Builder<'a>;

    #[inline]
    fn create_mut(data: &'a mut Vec<u8>) -> Self::ItemMut
    {
        Self::ItemMut { data }
    }
}
/// Enum for read-only heterogeneous access to elements in a
/// bucket of the [`multilist2`] resource.
///
/// [`multilist2`]: struct.Archive{.n.A}.html#method.multilist2
#[derive(Clone, PartialEq)]
pub enum Multilist2Ref<'a> {
    #[allow(missing_docs)]
    S(&'a super::n::S),}

impl<'a> ::std::fmt::Debug for Multilist2Ref<'a> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            Multilist2Ref::S(ref inner) => write!(f, "{:?}", inner),
        }
    }
}

impl<'a> flatdata::VariadicRef for Multilist2Ref<'a> {
    #[inline]
    fn size_in_bytes(&self) -> usize {
        match *self {
            Multilist2Ref::S(_) => <super::n::S as flatdata::Struct>::SIZE_IN_BYTES,
        }
    }
}

/// Builder of buckets in the [`multilist2`] resource.
///
/// Refers to a single bucket in the [`multilist2`] multivector and
/// provides methods for adding heterogeneous data to the bucket.
///
/// [`multilist2`]: struct.Archive{.n.A}.html#method.multilist2
pub struct Multilist2Builder<'a> {
    data: &'a mut Vec<u8>
}

impl<'a> Multilist2Builder<'a> {
    /// Adds data of the type [`S`] to the bucket.
    ///
    /// [`S`]: struct.S.html
    #[inline]
    pub fn add_s<'b>(&'b mut self) -> &'b mut super::n::S {
        let old_len = self.data.len();
        let increment = 1 + <super::n::S as flatdata::Struct>::SIZE_IN_BYTES;
        self.data.resize(old_len + increment, 0);
        self.data[old_len] = 0;
        let slice = &mut self.data[1 + old_len..];
        super::n::S::from_bytes_slice_mut(slice).expect("Logic error: Cannot create super::n::S from slice")
    }
}

/// Variadic struct attached to the [`multilist2`] archive resource.
///
/// It unifies the following data types:
//
/// * [`S`]
///
/// ## Access pattern
///
/// This structure is used as a template parameter in [`multilist2`] multivector/
/// multiarray view. It does not contain any data, instead it references
///
/// * [`Multilist2Ref`] for the read-only heterogeneous access, and
/// * [`Multilist2Builder`] for the mutable builder pattern access.
///
/// [`multilist2`]: struct.Archive{.n.A}.html#method.multilist2
/// [`Multilist2Ref`]: enum.Multilist2Ref.html
/// [`Multilist2Builder`]: struct.Multilist2Builder.html
/// [`S`]: struct.S.html
#[derive(Clone)]
pub struct Multilist2 {}

impl flatdata::VariadicIndex for Multilist2 {
    type Index = super::_builtin::multivector::IndexType32;
}

impl<'a> flatdata::VariadicStruct<'a> for Multilist2 {
    type Item = Multilist2Ref<'a>;

    #[inline]
    fn create(index: flatdata::TypeIndex, data: &'a [u8]) -> Self::Item
    {
        match index {
                0 => Multilist2Ref::S(super::n::S::from_bytes_slice(&data).expect("Corrupted data")),
            _ => panic!("invalid type index {} for variadic type Multilist2Ref", index),
        }
    }

    type ItemMut = Multilist2Builder<'a>;

    #[inline]
    fn create_mut(data: &'a mut Vec<u8>) -> Self::ItemMut
    {
        Self::ItemMut { data }
    }
}
/// Enum for read-only heterogeneous access to elements in a
/// bucket of the [`multirefs`] resource.
///
/// [`multirefs`]: struct.Archive{.n.A}.html#method.multirefs
#[derive(Clone, PartialEq)]
pub enum MultirefsRef<'a> {
    #[allow(missing_docs)]
    R(&'a super::n::R),}

impl<'a> ::std::fmt::Debug for MultirefsRef<'a> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            MultirefsRef::R(ref inner) => write!(f, "{:?}", inner),
        }
    }
}

impl<'a> flatdata::VariadicRef for MultirefsRef<'a> {
    #[inline]
    fn size_in_bytes(&self) -> usize {
        match *self {
            MultirefsRef::R(_) => <super::n::R as flatdata::Struct>::SIZE_IN_BYTES,
        }
    }
}

/// Builder of buckets in the [`multirefs`] resource.
///
/// Refers to a single bucket in the [`multirefs`] multivector and
/// provides methods for adding heterogeneous data to the bucket.
///
/// [`multirefs`]: struct.Archive{.n.A}.html#method.multirefs
pub struct MultirefsBuilder<'a> {
    data: &'a mut Vec<u8>
}

impl<'a> MultirefsBuilder<'a> {
    /// Adds data of the type [`R`] to the bucket.
    ///
    /// [`R`]: struct.R.html
    #[inline]
    pub fn add_r<'b>(&'b mut self) -> &'b mut super::n::R {
        let old_len = self.data.len();
        let increment = 1 + <super::n::R as flatdata::Struct>::SIZE_IN_BYTES;
        self.data.resize(old_len + increment, 0);
        self.data[old_len] = 0;
        let slice = &mut self.data[1 + old_len..];
        super::n::R::from_bytes_slice_mut(slice).expect("Logic error: Cannot create super::n::R from slice")
    }
}

/// Variadic struct attached to the [`multirefs`] archive resource.
///
/// It unifies the following data types:
//
/// * [`R`]
///
/// ## Access pattern
///
/// This structure is used as a template parameter in [`multirefs`] multivector/
/// multiarray view. It does not contain any data, instead it references
///
/// * [`MultirefsRef`] for the read-only heterogeneous access, and
/// * [`MultirefsBuilder`] for the mutable builder pattern access.
///
/// [`multirefs`]: struct.Archive{.n.A}.html#method.multirefs
/// [`MultirefsRef`]: enum.MultirefsRef.html
/// [`MultirefsBuilder`]: struct.MultirefsBuilder.html
/// [`R`]: struct.R.html
#[derive(Clone)]
pub struct Multirefs {}

impl flatdata::VariadicIndex for Multirefs {
    type Index = super::_builtin::multivector::IndexType32;
}

impl<'a> flatdata::VariadicStruct<'a> for Multirefs {
    type Item = MultirefsRef<'a>;

    #[inline]
    fn create(index: flatdata::TypeIndex, data: &'a [u8]) -> Self::Item
    {
        match index {
                0 => MultirefsRef::R(super::n::R::from_bytes_slice(&data).expect("Corrupted data")),
            _ => panic!("invalid type index {} for variadic type MultirefsRef", index),
        }
    }

    type ItemMut = MultirefsBuilder<'a>;

    #[inline]
    fn create_mut(data: &'a mut Vec<u8>) -> Self::ItemMut
    {
        Self::ItemMut { data }
    }
}

#[derive(Clone)]
pub struct A {
    _storage: flatdata::StorageHandle,
    list1 : Option<&'static [super::n::S]>,
    list2 : &'static [super::n::S],
    multilist1 : Option<flatdata::MultiArrayView<'static, Multilist1>>,
    multilist2 : flatdata::MultiArrayView<'static, Multilist2>,
    raw1 : Option<flatdata::RawData<'static>>,
    raw2 : flatdata::RawData<'static>,
    refs : &'static [super::n::R],
    multirefs : flatdata::MultiArrayView<'static, Multirefs>,
}

impl A {
    fn signature_name(archive_name: &str) -> String {
        format!("{}.archive", archive_name)
    }

    #[inline]
    pub fn list1(&self) -> Option<&[super::n::S]> {
        self.list1
    }

    #[inline]
    pub fn list2(&self) -> &[super::n::S] {
        self.list2
    }

    #[inline]
    pub fn multilist1(&self) -> Option<&flatdata::MultiArrayView<Multilist1>> {
        self.multilist1.as_ref()
    }

    #[inline]
    pub fn multilist2(&self) -> &flatdata::MultiArrayView<Multilist2> {
        &self.multilist2
    }

    #[inline]
    pub fn raw1(&self) -> Option<flatdata::RawData> {
        self.raw1
    }

    #[inline]
    pub fn raw2(&self) -> flatdata::RawData {
        self.raw2
    }

    #[inline]
    pub fn refs(&self) -> &[super::n::R] {
        self.refs
    }

    #[inline]
    pub fn multirefs(&self) -> &flatdata::MultiArrayView<Multirefs> {
        &self.multirefs
    }

}

impl ::std::fmt::Debug for A {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct("A")
            .field("list1", &self.list1())
            .field("list2", &self.list2())
            .field("multilist1", &self.multilist1())
            .field("multilist2", &self.multilist2())
            .field("raw1", &self.raw1())
            .field("raw2", &self.raw2())
            .field("refs", &self.refs())
            .field("multirefs", &self.multirefs())
            .finish()
    }
}

impl A {
    pub fn open(storage: flatdata::StorageHandle)
        -> ::std::result::Result<Self, flatdata::ResourceStorageError>
    {
        #[allow(unused_imports)]
        use flatdata::SliceExt;
        // extend lifetime since Rust cannot know that we reference a cache here
        #[allow(unused_variables)]
        let extend = |x : Result<&[u8], flatdata::ResourceStorageError>| -> Result<&'static [u8], flatdata::ResourceStorageError> {x.map(|x| unsafe{std::mem::transmute(x)})};

        storage.read(&Self::signature_name("A"), schema::a::A)?;

        let resource = extend(storage.read("list1", schema::a::resources::LIST1));
        let list1 = resource.map(|x| <&[super::n::S]>::from_bytes(x)).ok().transpose()?;
        let size = list1.as_ref().map(|r| r.len()).unwrap_or(0);
        if size > 16 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "list1", size}); }
        let resource = extend(storage.read("list2", schema::a::resources::LIST2));
        let list2 = resource.map(|x| <&[super::n::S]>::from_bytes(x))??;
        let size = list2.len();
        if size > 16 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "list2", size}); }
        let multilist1 = {
            let index_schema = &format!("index({})", schema::a::resources::MULTILIST1);
            let index = extend(storage.read("multilist1_index", &index_schema));
            let data = extend(storage.read("multilist1", schema::a::resources::MULTILIST1));
            let result = match (index, data) {
                (Ok(index), Ok(data)) => {
                    Ok(flatdata::MultiArrayView::new(
                        <&[super::_builtin::multivector::IndexType32]>::from_bytes(index)?,
                        data
                    ))
                }
                (Ok(_), Err(x)) | (Err(x), Ok(_)) => {return Err(x);}
                (Err(x), Err(_)) => Err(x),
            };
            result.ok()
        };
        let size = multilist1.as_ref().map(|r| r.len()).unwrap_or(0);
        if size > 16 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "multilist1", size}); }
        let multilist2 = {
            let index_schema = &format!("index({})", schema::a::resources::MULTILIST2);
            let index = extend(storage.read("multilist2_index", &index_schema));
            let data = extend(storage.read("multilist2", schema::a::resources::MULTILIST2));
            let result = match (index, data) {
                (Ok(index), Ok(data)) => {
                    Ok(flatdata::MultiArrayView::new(
                        <&[super::_builtin::multivector::IndexType32]>::from_bytes(index)?,
                        data
                    ))
                }
                (Ok(_), Err(x)) | (Err(x), Ok(_)) => {return Err(x);}
                (Err(x), Err(_)) => Err(x),
            };
            result?
        };
        let size = multilist2.len();
        if size > 16 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "multilist2", size}); }
        let resource = extend(storage.read("raw1", schema::a::resources::RAW1));
        let raw1 = resource.map(|x| flatdata::RawData::new(x)).ok();
        let size = raw1.as_ref().map(|r| r.len()).unwrap_or(0);
        if size > 16 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "raw1", size}); }
        let resource = extend(storage.read("raw2", schema::a::resources::RAW2));
        let raw2 = resource.map(|x| flatdata::RawData::new(x))?;
        let size = raw2.len();
        if size > 16 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "raw2", size}); }
        let resource = extend(storage.read("refs", schema::a::resources::REFS));
        let refs = resource.map(|x| <&[super::n::R]>::from_bytes(x))??;
        let multirefs = {
            let index_schema = &format!("index({})", schema::a::resources::MULTIREFS);
            let index = extend(storage.read("multirefs_index", &index_schema));
            let data = extend(storage.read("multirefs", schema::a::resources::MULTIREFS));
            let result = match (index, data) {
                (Ok(index), Ok(data)) => {
                    Ok(flatdata::MultiArrayView::new(
                        <&[super::_builtin::multivector::IndexType32]>::from_bytes(index)?,
                        data
                    ))
                }
                (Ok(_), Err(x)) | (Err(x), Ok(_)) => {return Err(x);}
                (Err(x), Err(_)) => Err(x),
            };
            result?
        };

        Ok(Self {
            _storage: storage,
            list1,
            list2,
            multilist1,
            multilist2,
            raw1,
            raw2,
            refs,
            multirefs,
        })
    }
}

/// Builder for creating [`A`] archives.
///
///[`A`]: struct.A.html
#[derive(Clone, Debug)]
pub struct ABuilder {
    storage: flatdata::StorageHandle
}

impl ABuilder {
    #[inline]
    /// Stores [`list1`] in the archive.
    ///
    /// [`list1`]: struct.A.html#method.list1
    pub fn set_list1(&self, vector: &[super::n::S]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("list1", schema::a::resources::LIST1, vector.as_bytes())
    }

    /// Opens [`list1`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`list1`]: struct.A.html#method.list1
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_list1(&self) -> ::std::io::Result<flatdata::ExternalVector<super::n::S>> {
        flatdata::create_external_vector(&*self.storage, "list1", schema::a::resources::LIST1)
    }

    #[inline]
    /// Stores [`list2`] in the archive.
    ///
    /// [`list2`]: struct.A.html#method.list2
    pub fn set_list2(&self, vector: &[super::n::S]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("list2", schema::a::resources::LIST2, vector.as_bytes())
    }

    /// Opens [`list2`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`list2`]: struct.A.html#method.list2
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_list2(&self) -> ::std::io::Result<flatdata::ExternalVector<super::n::S>> {
        flatdata::create_external_vector(&*self.storage, "list2", schema::a::resources::LIST2)
    }

    /// Opens [`multilist1`] in the archive for buffered writing.
    ///
    /// Elements can be added to the multivector until the [`MultiVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`multilist1`]: struct.A.html#method.multilist1
    /// [`MultiVector::close`]: flatdata/struct.MultiVector.html#method.close
    #[inline]
    pub fn start_multilist1(&self) -> ::std::io::Result<flatdata::MultiVector<Multilist1>> {
        flatdata::create_multi_vector(&*self.storage, "multilist1", schema::a::resources::MULTILIST1)
    }

    /// Opens [`multilist2`] in the archive for buffered writing.
    ///
    /// Elements can be added to the multivector until the [`MultiVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`multilist2`]: struct.A.html#method.multilist2
    /// [`MultiVector::close`]: flatdata/struct.MultiVector.html#method.close
    #[inline]
    pub fn start_multilist2(&self) -> ::std::io::Result<flatdata::MultiVector<Multilist2>> {
        flatdata::create_multi_vector(&*self.storage, "multilist2", schema::a::resources::MULTILIST2)
    }

    /// Stores [`raw1`] in the archive.
    ///
    /// [`raw1`]: struct.A.html#method.raw1
    #[inline]
    pub fn set_raw1(&self, data: &[u8]) -> ::std::io::Result<()> {
        self.storage.write("raw1", schema::a::resources::RAW1, data)
    }

    /// Stores [`raw2`] in the archive.
    ///
    /// [`raw2`]: struct.A.html#method.raw2
    #[inline]
    pub fn set_raw2(&self, data: &[u8]) -> ::std::io::Result<()> {
        self.storage.write("raw2", schema::a::resources::RAW2, data)
    }

    #[inline]
    /// Stores [`refs`] in the archive.
    ///
    /// [`refs`]: struct.A.html#method.refs
    pub fn set_refs(&self, vector: &[super::n::R]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("refs", schema::a::resources::REFS, vector.as_bytes())
    }

    /// Opens [`refs`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`refs`]: struct.A.html#method.refs
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_refs(&self) -> ::std::io::Result<flatdata::ExternalVector<super::n::R>> {
        flatdata::create_external_vector(&*self.storage, "refs", schema::a::resources::REFS)
    }

    /// Opens [`multirefs`] in the archive for buffered writing.
    ///
    /// Elements can be added to the multivector until the [`MultiVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`multirefs`]: struct.A.html#method.multirefs
    /// [`MultiVector::close`]: flatdata/struct.MultiVector.html#method.close
    #[inline]
    pub fn start_multirefs(&self) -> ::std::io::Result<flatdata::MultiVector<Multirefs>> {
        flatdata::create_multi_vector(&*self.storage, "multirefs", schema::a::resources::MULTIREFS)
    }

}

impl ABuilder {
    pub fn new(
        storage: flatdata::StorageHandle,
    ) -> Result<Self, flatdata::ResourceStorageError> {
        flatdata::create_archive("A", schema::a::A, &storage)?;
        Ok(Self { storage })
    }
}


#[doc(hidden)]
pub mod schema {
pub mod a {

pub const A: &str = r#"namespace n {
struct S
{
    x : u32 : 32;
}
}

namespace n {
struct R
{
    ref : u32 : 8;
    ref2 : u32 : 4;
}
}

namespace n {
@bound_implicitly( all_lists : .n.A.list1, .n.A.list2, .n.A.multilist1 )
archive A
{
    @optional
    list1 : vector< .n.S >;
    list2 : vector< .n.S >;
    @optional
    multilist1 : multivector< 32, .n.S >;
    multilist2 : multivector< 32, .n.S >;
    @optional
    raw1 : raw_data;
    raw2 : raw_data;
    @explicit_reference( .n.R.ref, .n.A.list1 )
    @explicit_reference( .n.R.ref2, .n.A.list1 )
    @explicit_reference( .n.R.ref2, .n.A.list2 )
    @explicit_reference( .n.R.ref2, .n.A.multilist1 )
    @explicit_reference( .n.R.ref2, .n.A.multilist2 )
    @explicit_reference( .n.R.ref2, .n.A.raw1 )
    @explicit_reference( .n.R.ref2, .n.A.raw2 )
    refs : vector< .n.R >;
    @explicit_reference( .n.R.ref, .n.A.list1 )
    multirefs : multivector< 32, .n.R >;
}
}

"#;

pub mod resources {
pub const LIST1: &str = r#"namespace n {
struct S
{
    x : u32 : 32;
}
}

namespace n {
archive A
{
    @optional
    list1 : vector< .n.S >;
}
}

"#;
pub const LIST2: &str = r#"namespace n {
struct S
{
    x : u32 : 32;
}
}

namespace n {
archive A
{
    list2 : vector< .n.S >;
}
}

"#;
pub const MULTILIST1: &str = r#"namespace n {
struct S
{
    x : u32 : 32;
}
}

namespace n {
archive A
{
    @optional
    multilist1 : multivector< 32, .n.S >;
}
}

"#;
pub const MULTILIST2: &str = r#"namespace n {
struct S
{
    x : u32 : 32;
}
}

namespace n {
archive A
{
    multilist2 : multivector< 32, .n.S >;
}
}

"#;
pub const RAW1: &str = r#"namespace n {
archive A
{
    @optional
    raw1 : raw_data;
}
}

"#;
pub const RAW2: &str = r#"namespace n {
archive A
{
    raw2 : raw_data;
}
}

"#;
pub const REFS: &str = r#"namespace n {
struct R
{
    ref : u32 : 8;
    ref2 : u32 : 4;
}
}

namespace n {
archive A
{
    @explicit_reference( .n.R.ref, .n.A.list1 )
    @explicit_reference( .n.R.ref2, .n.A.list1 )
    @explicit_reference( .n.R.ref2, .n.A.list2 )
    @explicit_reference( .n.R.ref2, .n.A.multilist1 )
    @explicit_reference( .n.R.ref2, .n.A.multilist2 )
    @explicit_reference( .n.R.ref2, .n.A.raw1 )
    @explicit_reference( .n.R.ref2, .n.A.raw2 )
    refs : vector< .n.R >;
}
}

"#;
pub const MULTIREFS: &str = r#"namespace n {
struct R
{
    ref : u32 : 8;
    ref2 : u32 : 4;
}
}

namespace n {
archive A
{
    @explicit_reference( .n.R.ref, .n.A.list1 )
    multirefs : multivector< 32, .n.R >;
}
}

"#;
}
}
}
}

#[doc(hidden)]
pub mod _builtin {

#[allow(missing_docs)]
pub mod multivector {

/// Builtin type to for MultiVector index
#[repr(transparent)]
pub struct IndexType32 {
    data: [u8; 4],
}

impl IndexType32 {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 4]}
    }
}

impl flatdata::Struct for IndexType32 {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 4]}
    }

    const SIZE_IN_BYTES: usize = 4;
    const IS_OVERLAPPING_WITH_NEXT : bool = true;
}

impl flatdata::Overlap for IndexType32 {}

impl IndexType32 {
    /// First element of the range [`range`].
    ///
    /// [`range`]: #method.range
    #[inline]
    pub fn value(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 32);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    #[inline]
    pub fn range(&self) -> std::ops::Range<u64> {
        let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 32);
        let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 0 + 4 * 8, 32);
        start..end
    }

}

impl std::fmt::Debug for IndexType32 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("IndexType32")
            .field("value", &self.value())
            .finish()
    }
}

impl std::cmp::PartialEq for IndexType32 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.value() == other.value()     }
}

impl IndexType32 {
    /// First element of the range [`range`].
    ///
    /// [`range`]: struct.IndexType32Ref.html#method.range
    #[inline]
    #[allow(missing_docs)]
    pub fn set_value(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 0, 32)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &IndexType32) {
        self.set_value(other.value());
    }
}

impl flatdata::IndexStruct for IndexType32 {
    #[inline]
    fn range(&self) -> std::ops::Range<usize> {
        let range = self.range();
        range.start as usize..range.end as usize
    }

    #[inline]
    fn set_index(&mut self, value: usize) {
        self.set_value(value as u64);
    }
}


#[doc(hidden)]
pub mod schema {
}
}

#[doc(hidden)]
pub mod schema {
}
}
