// Do not edit: This code was generated by flatdata's generator.
pub mod test {

    pub mod schema {
        pub mod structs {
            pub const A: &str = r#"namespace test {
enum E : u32
{
    Value = 0,
}
}

namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
    e : .test.E : 16;
}
}

"#;
            pub const R: &str = r#"namespace test {
struct R
{
    @range( x )
    first_x : u32 : 16;
    y : u32 : 16;
}
}

"#;
        }
        pub mod x {
            pub const X: &str = r#"namespace test {
enum E : u32
{
    Value = 0,
}
}

namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
    e : .test.E : 16;
}
}

namespace test {
archive X
{
    data : vector< .test.A >;
}
}

"#;
            pub mod resources {
                pub const DATA: &str = r#"namespace test {
enum E : u32
{
    Value = 0,
}
}

namespace test {
struct A
{
    x : u32 : 16;
    y : u32 : 16;
    e : .test.E : 16;
}
}

namespace test {
archive X
{
    data : vector< .test.A >;
}
}

"#;
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct A {}

    #[derive(Clone, Copy)]
    pub struct ARef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> crate::Struct<'a> for A {
        const SCHEMA: &'static str = schema::structs::A;
        const SIZE_IN_BYTES: usize = 6;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;

        type Item = ARef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = AMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl crate::NoOverlap for A {}

    impl<'a> ARef<'a> {
        #[inline]
        pub fn x(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 0, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }
        #[inline]
        pub fn y(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 16, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }
        #[inline]
        pub fn e(&self) -> super::test::E {
            let value = flatdata_read_bytes!(u32, self.data, 32, 16);
            unsafe { std::mem::transmute::<u32, super::test::E>(value) }
        }
        #[inline]
        pub fn as_ptr(&self) -> *const u8 {
            self.data
        }
    }

    impl<'a> std::fmt::Debug for ARef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("A")
                .field("x", &self.x())
                .field("y", &self.y())
                .field("e", &self.e())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for ARef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.x() == other.x() && self.y() == other.y() && self.e() == other.e()
        }
    }

    impl<'a> crate::Ref for ARef<'a> {}

    pub struct AMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> AMut<'a> {
        #[inline]
        pub fn x(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 0, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        #[inline]
        pub fn set_x(&mut self, value: u32) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 6) };
            flatdata_write_bytes!(u32; value, buffer, 0, 16)
        }

        #[inline]
        pub fn y(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 16, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        #[inline]
        pub fn set_y(&mut self, value: u32) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 6) };
            flatdata_write_bytes!(u32; value, buffer, 16, 16)
        }

        #[inline]
        pub fn e(&self) -> super::test::E {
            let value = flatdata_read_bytes!(u32, self.data, 32, 16);
            unsafe { std::mem::transmute::<u32, super::test::E>(value) }
        }

        #[inline]
        pub fn set_e(&mut self, value: super::test::E) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 6) };
            flatdata_write_bytes!(u32; value, buffer, 32, 16)
        }

        #[inline]
        pub fn fill_from(&mut self, other: &ARef) {
            self.set_x(other.x());
            self.set_y(other.y());
            self.set_e(other.e());
        }

        #[inline]
        pub fn as_ptr(&self) -> *const u8 {
            self.data
        }

        #[inline]
        pub fn as_mut_ptr(&self) -> *mut u8 {
            self.data
        }
    }

    impl<'a> std::fmt::Debug for AMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            ARef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> crate::RefMut for AMut<'a> {}

    #[derive(Clone, Debug)]
    pub struct R {}

    #[derive(Clone, Copy)]
    pub struct RRef<'a> {
        data: *const u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> crate::Struct<'a> for R {
        const SCHEMA: &'static str = schema::structs::R;
        const SIZE_IN_BYTES: usize = 4;
        const IS_OVERLAPPING_WITH_NEXT: bool = true;

        type Item = RRef<'a>;

        #[inline]
        fn create(data: &'a [u8]) -> Self::Item {
            Self::Item {
                data: data.as_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }

        type ItemMut = RMut<'a>;

        #[inline]
        fn create_mut(data: &'a mut [u8]) -> Self::ItemMut {
            Self::ItemMut {
                data: data.as_mut_ptr(),
                _phantom: std::marker::PhantomData,
            }
        }
    }

    impl<'a> RRef<'a> {
        #[inline]
        pub fn first_x(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 0, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }
        #[inline]
        pub fn x(&self) -> std::ops::Range<u32> {
            let start = flatdata_read_bytes!(u32, self.data, 0, 16);
            let end = flatdata_read_bytes!(u32, self.data, 0 + 4 * 8, 16);
            start..end
        }

        #[inline]
        pub fn y(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 16, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }
        #[inline]
        pub fn as_ptr(&self) -> *const u8 {
            self.data
        }
    }

    impl<'a> std::fmt::Debug for RRef<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("R")
                .field("first_x", &self.first_x())
                .field("y", &self.y())
                .finish()
        }
    }

    impl<'a> std::cmp::PartialEq for RRef<'a> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.first_x() == other.first_x() && self.y() == other.y()
        }
    }

    impl<'a> crate::Ref for RRef<'a> {}

    pub struct RMut<'a> {
        data: *mut u8,
        _phantom: std::marker::PhantomData<&'a u8>,
    }

    impl<'a> RMut<'a> {
        #[inline]
        pub fn first_x(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 0, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        #[inline]
        pub fn set_first_x(&mut self, value: u32) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 4) };
            flatdata_write_bytes!(u32; value, buffer, 0, 16)
        }

        #[inline]
        pub fn y(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data, 16, 16);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        #[inline]
        pub fn set_y(&mut self, value: u32) {
            let buffer = unsafe { std::slice::from_raw_parts_mut(self.data, 4) };
            flatdata_write_bytes!(u32; value, buffer, 16, 16)
        }

        #[inline]
        pub fn fill_from(&mut self, other: &RRef) {
            self.set_first_x(other.first_x());
            self.set_y(other.y());
        }

        #[inline]
        pub fn as_ptr(&self) -> *const u8 {
            self.data
        }

        #[inline]
        pub fn as_mut_ptr(&self) -> *mut u8 {
            self.data
        }
    }

    impl<'a> std::fmt::Debug for RMut<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            RRef {
                data: self.data,
                _phantom: std::marker::PhantomData,
            }
            .fmt(f)
        }
    }

    impl<'a> crate::RefMut for RMut<'a> {}

    #[derive(Debug, PartialEq, Eq)]
    #[repr(u32)]
    pub enum E {
        Value = 0,
    }

    impl crate::helper::Int for E {
        const IS_SIGNED: bool = false;
    }

    #[derive(Clone)]
    pub struct X {
        _storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
        data: crate::MemoryDescriptor,
    }

    impl X {
        fn read_resource(
            storage: &dyn crate::ResourceStorage,
            name: &str,
            schema: &str,
        ) -> Result<crate::MemoryDescriptor, crate::ResourceStorageError> {
            storage
                .read(name, schema)
                .map(|x| crate::MemoryDescriptor::new(&x))
        }

        fn signature_name(archive_name: &str) -> String {
            format!("{}.archive", archive_name)
        }

        #[inline]
        pub fn data(&self) -> crate::ArrayView<super::test::A> {
            crate::ArrayView::new(&unsafe { self.data.as_bytes() })
        }
    }

    impl ::std::fmt::Debug for X {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            f.debug_struct("X").field("data", &self.data()).finish()
        }
    }

    impl crate::Archive for X {
        const NAME: &'static str = "X";
        const SCHEMA: &'static str = schema::x::X;

        fn open(
            storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
        ) -> ::std::result::Result<Self, crate::ResourceStorageError> {
            storage.read(&Self::signature_name(Self::NAME), Self::SCHEMA)?;

            let data = Self::read_resource(&*storage, "data", schema::x::resources::DATA)?;

            Ok(Self {
                _storage: storage,
                data,
            })
        }
    }

    #[derive(Clone, Debug)]
    pub struct XBuilder {
        storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
    }

    impl XBuilder {
        #[inline]
        pub fn set_data(&self, vector: &crate::ArrayView<super::test::A>) -> ::std::io::Result<()> {
            self.storage
                .write("data", schema::x::resources::DATA, vector.as_ref())
        }

        #[inline]
        pub fn start_data(&self) -> ::std::io::Result<crate::ExternalVector<super::test::A>> {
            crate::create_external_vector(&*self.storage, "data", schema::x::resources::DATA)
        }
    }

    impl crate::ArchiveBuilder for XBuilder {
        const NAME: &'static str = "X";
        const SCHEMA: &'static str = schema::x::X;

        fn new(
            storage: ::std::rc::Rc<dyn crate::ResourceStorage>,
        ) -> Result<Self, crate::ResourceStorageError> {
            crate::create_archive::<Self>(&storage)?;
            Ok(Self { storage })
        }
    }
}
