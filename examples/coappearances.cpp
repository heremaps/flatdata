/**
 * Copyright (c) 2018 HERE Europe B.V.
 * See the LICENSE file in the root of this project for license details.
 */

#include "coappearances.hpp"  // generated by flatdata from coappearances.flatdata
#include "picojson.h"

#include <flatdata/flatdata.h>
#include <fstream>
#include <iostream>
#include <string>

namespace co = coappearances;

uint16_t
convert_id( const std::string& id )
{
    assert( id.size( ) == 2 );
    return ( static_cast< uint8_t >( id[ 0 ] ) << 8 ) + static_cast< uint8_t >( id[ 1 ] );
}

using CharactersIndex = std::map< uint16_t /* id */, uint16_t /* ref */ >;

CharactersIndex
build_characters_index( const picojson::object& characters )
{
    CharactersIndex index;
    if ( std::numeric_limits< uint16_t >::max( ) <= characters.size( ) )
    {
        throw std::runtime_error( "Too many characters for indexing by 16 bits" );
    }

    uint16_t ref = 0;
    for ( const auto& kv : characters )
    {
        uint16_t id = convert_id( kv.first );
        if ( index.count( id ) )
        {
            throw std::runtime_error( std::string( "Duplicate index " ) + kv.first );
        }
        index.emplace( id, ref );
        ref++;
    }
    return index;
}

std::pair< uint8_t /* major */, uint8_t /* minor */ >
convert_chapter( const std::string& s )
{
    auto pos = s.find( '.' );
    if ( pos == std::string::npos )
    {
        throw std::runtime_error( std::string( "Unexpected chapter format for " ) + s );
    }

    auto major = std::stoul( s.substr( 0, pos ) );
    if ( ( 1 << co::Chapter::MajorType::bit_width ) <= major )
    {
        throw std::runtime_error( "Major chapter overflow" );
    }

    auto minor = std::stoul( s.substr( pos + 1 ) );
    if ( ( 1 << co::Chapter::MinorType::bit_width ) <= minor )
    {
        throw std::runtime_error( "Major chapter overflow" );
    }

    return {static_cast< uint8_t >( major ), static_cast< uint8_t >( minor )};
}

void
convert_characters( const picojson::object& characters,
                    const CharactersIndex& characters_index,
                    co::GraphBuilder builder )
{
    auto vertices = builder.start_vertices( );
    auto vertices_data = builder.start_vertices_data( );
    std::string strings;  // list of zero-terminated strings

    for ( const auto& kv : characters )
    {
        const auto& id = kv.first;
        const auto& data = kv.second.get< picojson::object >( );

        auto character = vertices.grow( );
        vertices_data.next_item( );

        character.name_ref = strings.size( );
        strings += data.at( "name" ).get< std::string >( ) + '\0';

        if ( data.count( "nickname" ) )
        {
            auto nickname = vertices_data.add_to_current_item< co::Nickname >( );
            nickname.ref = strings.size( );
            strings += data.at( "nickname" ).get< std::string >( ) + '\0';
        }

        if ( data.count( "description" ) )
        {
            auto description = vertices_data.add_to_current_item< co::Description >( );
            description.ref = strings.size( );
            strings += data.at( "description" ).get< std::string >( ) + '\0';
        }

        if ( data.count( "relation" ) )
        {
            const auto& relation = data.at( "relation" ).get< picojson::object >( );
            if ( relation.at( "to" ).is< std::string >( ) )
            {
                auto rel = vertices_data.add_to_current_item< co::UnaryRelation >( );
                rel.kind_ref = strings.size( );
                strings += relation.at( "kind" ).get< std::string >( ) + '\0';
                rel.to_ref = characters_index.at(
                    convert_id( relation.at( "to" ).get< std::string >( ) ) );
            }
            else
            {
                auto rel = vertices_data.add_to_current_item< co::BinaryRelation >( );
                rel.kind_ref = strings.size( );
                strings += relation.at( "kind" ).get< std::string >( ) + '\0';
                auto to_refs = relation.at( "to" ).get< picojson::array >( );
                assert( to_refs.size( ) == 2 );
                rel.to_a_ref
                    = characters_index.at( convert_id( to_refs[ 0 ].get< std::string >( ) ) );
                rel.to_a_ref
                    = characters_index.at( convert_id( to_refs[ 1 ].get< std::string >( ) ) );
            }
        }
    }

    vertices.close( );
    vertices_data.close( );
    builder.set_strings( {strings.data( ), strings.size( )} );
}

void
convert_coappearances( const picojson::array& coappearances,
                       const CharactersIndex& characters_index,
                       co::GraphBuilder builder )
{
    auto edges = builder.start_edges( );
    auto chapters = builder.start_chapters( );
    for ( const auto& object : coappearances )
    {
        const auto& data = object.get< picojson::object >( );

        auto coappearance = edges.grow( );
        coappearance.a_ref
            = characters_index.at( convert_id( data.at( "a" ).get< std::string >( ) ) );
        coappearance.b_ref
            = characters_index.at( convert_id( data.at( "b" ).get< std::string >( ) ) );
        const auto& data_chapters = data.at( "chapters" ).get< picojson::array >( );
        coappearance.count = data_chapters.size( );
        coappearance.first_chapter_ref = chapters.size( );

        for ( const auto& data_chapter : data_chapters )
        {
            const auto& major_minor = convert_chapter( data_chapter.get< std::string >( ) );
            auto chapter = chapters.grow( );
            chapter.major = major_minor.first;
            chapter.minor = major_minor.second;
        }
    }

    // add sentinel to edges for easier access of chapters range
    auto sentinel = edges.grow( );
    sentinel.a_ref = std::numeric_limits< uint16_t >::max( );
    sentinel.b_ref = std::numeric_limits< uint16_t >::max( );
    sentinel.first_chapter_ref = chapters.size( );

    edges.close( );
    chapters.close( );
}

void
convert( const char* json_path, const char* archive_path )
{
    // parse json
    std::ifstream json_file( json_path );
    if ( !json_file.is_open( ) )
    {
        throw std::runtime_error( std::string( "Could not open " ) + json_path );
    }
    picojson::value json;
    json_file >> json;
    auto err = picojson::get_last_error( );
    if ( !err.empty( ) )
    {
        throw std::runtime_error( err );
    }
    const auto& root = json.get< picojson::object >( );

    // create new flatdata archive
    auto storage = flatdata::FileResourceStorage::create( archive_path );
    auto builder = co::GraphBuilder::open( std::move( storage ) );

    // convert and serialize
    const auto& characters = root.at( "characters" ).get< picojson::object >( );
    const auto& characters_index = build_characters_index( characters );
    convert_characters( characters, characters_index, builder );
    const auto& coappearances = root.at( "coappearances" ).get< picojson::array >( );
    convert_coappearances( coappearances, characters_index, builder );
}

void
read( const char* archive_path )
{
    auto storage = flatdata::FileResourceStorage::create( archive_path );
    auto graph = graph::Graph::open( std::move( storage ) );

    throw std::runtime_error( "not implemented" );
}

static const char* USAGE = 1 + R"_(
Usage:
  coappearances convert <input.json> <output_folder>
  coappearances read <output_folder>)_";

int
main( int argc, char const* argv[] )
{
    if ( argc < 3 )
    {
        std::cerr << USAGE << std::endl;
        return 1;
    }

    std::string verb( argv[ 1 ] );
    try
    {
        if ( verb == "convert" && argc == 4 )
        {
            convert( argv[ 2 ], argv[ 3 ] );
        }
        else if ( verb == "read" && argc == 3 )
        {
            return read( argv[ 2 ] );
        }
        else
        {
            std::cerr << USAGE << std::endl;
            return 1;
        }
    }
    catch ( std::runtime_error err )
    {
        std::cerr << "Error: " << err.what( ) << std::endl;
    }

    return 0;
}
